{
  "version": 3,
  "sources": ["../../heap/lib/heap.js", "../../heap/index.js", "../../pathfinding/src/core/Node.js", "../../pathfinding/src/core/DiagonalMovement.js", "../../pathfinding/src/core/Grid.js", "../../pathfinding/src/core/Util.js", "../../pathfinding/src/core/Heuristic.js", "../../pathfinding/src/finders/AStarFinder.js", "../../pathfinding/src/finders/BestFirstFinder.js", "../../pathfinding/src/finders/BreadthFirstFinder.js", "../../pathfinding/src/finders/DijkstraFinder.js", "../../pathfinding/src/finders/BiAStarFinder.js", "../../pathfinding/src/finders/BiBestFirstFinder.js", "../../pathfinding/src/finders/BiBreadthFirstFinder.js", "../../pathfinding/src/finders/BiDijkstraFinder.js", "../../pathfinding/src/finders/IDAStarFinder.js", "../../pathfinding/src/finders/JumpPointFinderBase.js", "../../pathfinding/src/finders/JPFNeverMoveDiagonally.js", "../../pathfinding/src/finders/JPFAlwaysMoveDiagonally.js", "../../pathfinding/src/finders/JPFMoveDiagonallyIfNoObstacles.js", "../../pathfinding/src/finders/JPFMoveDiagonallyIfAtMostOneObstacle.js", "../../pathfinding/src/finders/JumpPointFinder.js", "../../pathfinding/src/PathFinding.js", "../../pathfinding/index.js", "../../react-flow-renderer/node_modules/zustand/esm/index.js", "../../react-flow-renderer/node_modules/zustand/esm/context.js", "../../react-flow-renderer/node_modules/@babel/runtime/helpers/esm/defineProperty.js", "../../react-flow-renderer/node_modules/@babel/runtime/helpers/esm/arrayLikeToArray.js", "../../react-flow-renderer/node_modules/@babel/runtime/helpers/esm/unsupportedIterableToArray.js", "../../react-flow-renderer/node_modules/@babel/runtime/helpers/esm/arrayWithHoles.js", "../../react-flow-renderer/node_modules/@babel/runtime/helpers/esm/iterableToArrayLimit.js", "../../react-flow-renderer/node_modules/@babel/runtime/helpers/esm/nonIterableRest.js", "../../react-flow-renderer/node_modules/@babel/runtime/helpers/esm/slicedToArray.js", "../../react-flow-renderer/node_modules/zustand/esm/shallow.js", "../../react-flow-renderer/node_modules/@babel/runtime/helpers/esm/arrayWithoutHoles.js", "../../react-flow-renderer/node_modules/@babel/runtime/helpers/esm/iterableToArray.js", "../../react-flow-renderer/node_modules/@babel/runtime/helpers/esm/nonIterableSpread.js", "../../react-flow-renderer/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js", "../../react-flow-renderer/node_modules/@babel/runtime/helpers/esm/objectWithoutPropertiesLoose.js", "../../react-flow-renderer/node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js", "../../react-flow-renderer/dist/esm/index2.js", "../../react-flow-renderer/dist/esm/index3.js", "../../react-flow-renderer/dist/esm/useUpdateNodeInternals.js", "../../react-flow-renderer/dist/esm/useNodes.js", "../../react-flow-renderer/node_modules/@babel/runtime/helpers/esm/typeof.js", "../../@tisoap/react-flow-smart-edge/src/functions/guaranteeWalkablePath.ts", "../../@tisoap/react-flow-smart-edge/src/functions/pointConversion.ts", "../../@tisoap/react-flow-smart-edge/src/functions/utils.ts", "../../@tisoap/react-flow-smart-edge/src/functions/createGrid.ts", "../../@tisoap/react-flow-smart-edge/src/functions/drawSvgPath.ts", "../../@tisoap/react-flow-smart-edge/src/functions/generatePath.ts", "../../@tisoap/react-flow-smart-edge/src/functions/getBoundingBoxes.ts", "../../@tisoap/react-flow-smart-edge/src/getSmartEdge/index.ts", "../../@tisoap/react-flow-smart-edge/src/SmartEdge/index.tsx", "../../@tisoap/react-flow-smart-edge/src/SmartBezierEdge/index.tsx", "../../@tisoap/react-flow-smart-edge/src/SmartStepEdge/index.tsx", "../../@tisoap/react-flow-smart-edge/src/SmartStraightEdge/index.tsx"],
  "sourcesContent": ["// Generated by CoffeeScript 1.8.0\n(function() {\n  var Heap, defaultCmp, floor, heapify, heappop, heappush, heappushpop, heapreplace, insort, min, nlargest, nsmallest, updateItem, _siftdown, _siftup;\n\n  floor = Math.floor, min = Math.min;\n\n\n  /*\n  Default comparison function to be used\n   */\n\n  defaultCmp = function(x, y) {\n    if (x < y) {\n      return -1;\n    }\n    if (x > y) {\n      return 1;\n    }\n    return 0;\n  };\n\n\n  /*\n  Insert item x in list a, and keep it sorted assuming a is sorted.\n  \n  If x is already in a, insert it to the right of the rightmost x.\n  \n  Optional args lo (default 0) and hi (default a.length) bound the slice\n  of a to be searched.\n   */\n\n  insort = function(a, x, lo, hi, cmp) {\n    var mid;\n    if (lo == null) {\n      lo = 0;\n    }\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    if (lo < 0) {\n      throw new Error('lo must be non-negative');\n    }\n    if (hi == null) {\n      hi = a.length;\n    }\n    while (lo < hi) {\n      mid = floor((lo + hi) / 2);\n      if (cmp(x, a[mid]) < 0) {\n        hi = mid;\n      } else {\n        lo = mid + 1;\n      }\n    }\n    return ([].splice.apply(a, [lo, lo - lo].concat(x)), x);\n  };\n\n\n  /*\n  Push item onto heap, maintaining the heap invariant.\n   */\n\n  heappush = function(array, item, cmp) {\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    array.push(item);\n    return _siftdown(array, 0, array.length - 1, cmp);\n  };\n\n\n  /*\n  Pop the smallest item off the heap, maintaining the heap invariant.\n   */\n\n  heappop = function(array, cmp) {\n    var lastelt, returnitem;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    lastelt = array.pop();\n    if (array.length) {\n      returnitem = array[0];\n      array[0] = lastelt;\n      _siftup(array, 0, cmp);\n    } else {\n      returnitem = lastelt;\n    }\n    return returnitem;\n  };\n\n\n  /*\n  Pop and return the current smallest value, and add the new item.\n  \n  This is more efficient than heappop() followed by heappush(), and can be\n  more appropriate when using a fixed size heap. Note that the value\n  returned may be larger than item! That constrains reasonable use of\n  this routine unless written as part of a conditional replacement:\n      if item > array[0]\n        item = heapreplace(array, item)\n   */\n\n  heapreplace = function(array, item, cmp) {\n    var returnitem;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    returnitem = array[0];\n    array[0] = item;\n    _siftup(array, 0, cmp);\n    return returnitem;\n  };\n\n\n  /*\n  Fast version of a heappush followed by a heappop.\n   */\n\n  heappushpop = function(array, item, cmp) {\n    var _ref;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    if (array.length && cmp(array[0], item) < 0) {\n      _ref = [array[0], item], item = _ref[0], array[0] = _ref[1];\n      _siftup(array, 0, cmp);\n    }\n    return item;\n  };\n\n\n  /*\n  Transform list into a heap, in-place, in O(array.length) time.\n   */\n\n  heapify = function(array, cmp) {\n    var i, _i, _j, _len, _ref, _ref1, _results, _results1;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    _ref1 = (function() {\n      _results1 = [];\n      for (var _j = 0, _ref = floor(array.length / 2); 0 <= _ref ? _j < _ref : _j > _ref; 0 <= _ref ? _j++ : _j--){ _results1.push(_j); }\n      return _results1;\n    }).apply(this).reverse();\n    _results = [];\n    for (_i = 0, _len = _ref1.length; _i < _len; _i++) {\n      i = _ref1[_i];\n      _results.push(_siftup(array, i, cmp));\n    }\n    return _results;\n  };\n\n\n  /*\n  Update the position of the given item in the heap.\n  This function should be called every time the item is being modified.\n   */\n\n  updateItem = function(array, item, cmp) {\n    var pos;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    pos = array.indexOf(item);\n    if (pos === -1) {\n      return;\n    }\n    _siftdown(array, 0, pos, cmp);\n    return _siftup(array, pos, cmp);\n  };\n\n\n  /*\n  Find the n largest elements in a dataset.\n   */\n\n  nlargest = function(array, n, cmp) {\n    var elem, result, _i, _len, _ref;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    result = array.slice(0, n);\n    if (!result.length) {\n      return result;\n    }\n    heapify(result, cmp);\n    _ref = array.slice(n);\n    for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n      elem = _ref[_i];\n      heappushpop(result, elem, cmp);\n    }\n    return result.sort(cmp).reverse();\n  };\n\n\n  /*\n  Find the n smallest elements in a dataset.\n   */\n\n  nsmallest = function(array, n, cmp) {\n    var elem, i, los, result, _i, _j, _len, _ref, _ref1, _results;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    if (n * 10 <= array.length) {\n      result = array.slice(0, n).sort(cmp);\n      if (!result.length) {\n        return result;\n      }\n      los = result[result.length - 1];\n      _ref = array.slice(n);\n      for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n        elem = _ref[_i];\n        if (cmp(elem, los) < 0) {\n          insort(result, elem, 0, null, cmp);\n          result.pop();\n          los = result[result.length - 1];\n        }\n      }\n      return result;\n    }\n    heapify(array, cmp);\n    _results = [];\n    for (i = _j = 0, _ref1 = min(n, array.length); 0 <= _ref1 ? _j < _ref1 : _j > _ref1; i = 0 <= _ref1 ? ++_j : --_j) {\n      _results.push(heappop(array, cmp));\n    }\n    return _results;\n  };\n\n  _siftdown = function(array, startpos, pos, cmp) {\n    var newitem, parent, parentpos;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    newitem = array[pos];\n    while (pos > startpos) {\n      parentpos = (pos - 1) >> 1;\n      parent = array[parentpos];\n      if (cmp(newitem, parent) < 0) {\n        array[pos] = parent;\n        pos = parentpos;\n        continue;\n      }\n      break;\n    }\n    return array[pos] = newitem;\n  };\n\n  _siftup = function(array, pos, cmp) {\n    var childpos, endpos, newitem, rightpos, startpos;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    endpos = array.length;\n    startpos = pos;\n    newitem = array[pos];\n    childpos = 2 * pos + 1;\n    while (childpos < endpos) {\n      rightpos = childpos + 1;\n      if (rightpos < endpos && !(cmp(array[childpos], array[rightpos]) < 0)) {\n        childpos = rightpos;\n      }\n      array[pos] = array[childpos];\n      pos = childpos;\n      childpos = 2 * pos + 1;\n    }\n    array[pos] = newitem;\n    return _siftdown(array, startpos, pos, cmp);\n  };\n\n  Heap = (function() {\n    Heap.push = heappush;\n\n    Heap.pop = heappop;\n\n    Heap.replace = heapreplace;\n\n    Heap.pushpop = heappushpop;\n\n    Heap.heapify = heapify;\n\n    Heap.updateItem = updateItem;\n\n    Heap.nlargest = nlargest;\n\n    Heap.nsmallest = nsmallest;\n\n    function Heap(cmp) {\n      this.cmp = cmp != null ? cmp : defaultCmp;\n      this.nodes = [];\n    }\n\n    Heap.prototype.push = function(x) {\n      return heappush(this.nodes, x, this.cmp);\n    };\n\n    Heap.prototype.pop = function() {\n      return heappop(this.nodes, this.cmp);\n    };\n\n    Heap.prototype.peek = function() {\n      return this.nodes[0];\n    };\n\n    Heap.prototype.contains = function(x) {\n      return this.nodes.indexOf(x) !== -1;\n    };\n\n    Heap.prototype.replace = function(x) {\n      return heapreplace(this.nodes, x, this.cmp);\n    };\n\n    Heap.prototype.pushpop = function(x) {\n      return heappushpop(this.nodes, x, this.cmp);\n    };\n\n    Heap.prototype.heapify = function() {\n      return heapify(this.nodes, this.cmp);\n    };\n\n    Heap.prototype.updateItem = function(x) {\n      return updateItem(this.nodes, x, this.cmp);\n    };\n\n    Heap.prototype.clear = function() {\n      return this.nodes = [];\n    };\n\n    Heap.prototype.empty = function() {\n      return this.nodes.length === 0;\n    };\n\n    Heap.prototype.size = function() {\n      return this.nodes.length;\n    };\n\n    Heap.prototype.clone = function() {\n      var heap;\n      heap = new Heap();\n      heap.nodes = this.nodes.slice(0);\n      return heap;\n    };\n\n    Heap.prototype.toArray = function() {\n      return this.nodes.slice(0);\n    };\n\n    Heap.prototype.insert = Heap.prototype.push;\n\n    Heap.prototype.top = Heap.prototype.peek;\n\n    Heap.prototype.front = Heap.prototype.peek;\n\n    Heap.prototype.has = Heap.prototype.contains;\n\n    Heap.prototype.copy = Heap.prototype.clone;\n\n    return Heap;\n\n  })();\n\n  if (typeof module !== \"undefined\" && module !== null ? module.exports : void 0) {\n    module.exports = Heap;\n  } else {\n    window.Heap = Heap;\n  }\n\n}).call(this);\n", "module.exports = require('./lib/heap');\n", "/**\r\n * A node in grid. \r\n * This class holds some basic information about a node and custom \r\n * attributes may be added, depending on the algorithms' needs.\r\n * @constructor\r\n * @param {number} x - The x coordinate of the node on the grid.\r\n * @param {number} y - The y coordinate of the node on the grid.\r\n * @param {boolean} [walkable] - Whether this node is walkable.\r\n */\r\nfunction Node(x, y, walkable) {\r\n    /**\r\n     * The x coordinate of the node on the grid.\r\n     * @type number\r\n     */\r\n    this.x = x;\r\n    /**\r\n     * The y coordinate of the node on the grid.\r\n     * @type number\r\n     */\r\n    this.y = y;\r\n    /**\r\n     * Whether this node can be walked through.\r\n     * @type boolean\r\n     */\r\n    this.walkable = (walkable === undefined ? true : walkable);\r\n}\r\n\r\nmodule.exports = Node;\r\n", "var DiagonalMovement = {\r\n    Always: 1,\r\n    Never: 2,\r\n    IfAtMostOneObstacle: 3,\r\n    OnlyWhenNoObstacles: 4\r\n};\r\n\r\nmodule.exports = DiagonalMovement;", "var Node = require('./Node');\r\nvar DiagonalMovement = require('./DiagonalMovement');\r\n\r\n/**\r\n * The Grid class, which serves as the encapsulation of the layout of the nodes.\r\n * @constructor\r\n * @param {number|Array<Array<(number|boolean)>>} width_or_matrix Number of columns of the grid, or matrix\r\n * @param {number} height Number of rows of the grid.\r\n * @param {Array<Array<(number|boolean)>>} [matrix] - A 0-1 matrix\r\n *     representing the walkable status of the nodes(0 or false for walkable).\r\n *     If the matrix is not supplied, all the nodes will be walkable.  */\r\nfunction Grid(width_or_matrix, height, matrix) {\r\n    var width;\r\n\r\n    if (typeof width_or_matrix !== 'object') {\r\n        width = width_or_matrix;\r\n    } else {\r\n        height = width_or_matrix.length;\r\n        width = width_or_matrix[0].length;\r\n        matrix = width_or_matrix;\r\n    }\r\n\r\n    /**\r\n     * The number of columns of the grid.\r\n     * @type number\r\n     */\r\n    this.width = width;\r\n    /**\r\n     * The number of rows of the grid.\r\n     * @type number\r\n     */\r\n    this.height = height;\r\n\r\n    /**\r\n     * A 2D array of nodes.\r\n     */\r\n    this.nodes = this._buildNodes(width, height, matrix);\r\n}\r\n\r\n/**\r\n * Build and return the nodes.\r\n * @private\r\n * @param {number} width\r\n * @param {number} height\r\n * @param {Array<Array<number|boolean>>} [matrix] - A 0-1 matrix representing\r\n *     the walkable status of the nodes.\r\n * @see Grid\r\n */\r\nGrid.prototype._buildNodes = function(width, height, matrix) {\r\n    var i, j,\r\n        nodes = new Array(height);\r\n\r\n    for (i = 0; i < height; ++i) {\r\n        nodes[i] = new Array(width);\r\n        for (j = 0; j < width; ++j) {\r\n            nodes[i][j] = new Node(j, i);\r\n        }\r\n    }\r\n\r\n\r\n    if (matrix === undefined) {\r\n        return nodes;\r\n    }\r\n\r\n    if (matrix.length !== height || matrix[0].length !== width) {\r\n        throw new Error('Matrix size does not fit');\r\n    }\r\n\r\n    for (i = 0; i < height; ++i) {\r\n        for (j = 0; j < width; ++j) {\r\n            if (matrix[i][j]) {\r\n                // 0, false, null will be walkable\r\n                // while others will be un-walkable\r\n                nodes[i][j].walkable = false;\r\n            }\r\n        }\r\n    }\r\n\r\n    return nodes;\r\n};\r\n\r\n\r\nGrid.prototype.getNodeAt = function(x, y) {\r\n    return this.nodes[y][x];\r\n};\r\n\r\n\r\n/**\r\n * Determine whether the node at the given position is walkable.\r\n * (Also returns false if the position is outside the grid.)\r\n * @param {number} x - The x coordinate of the node.\r\n * @param {number} y - The y coordinate of the node.\r\n * @return {boolean} - The walkability of the node.\r\n */\r\nGrid.prototype.isWalkableAt = function(x, y) {\r\n    return this.isInside(x, y) && this.nodes[y][x].walkable;\r\n};\r\n\r\n\r\n/**\r\n * Determine whether the position is inside the grid.\r\n * XXX: `grid.isInside(x, y)` is wierd to read.\r\n * It should be `(x, y) is inside grid`, but I failed to find a better\r\n * name for this method.\r\n * @param {number} x\r\n * @param {number} y\r\n * @return {boolean}\r\n */\r\nGrid.prototype.isInside = function(x, y) {\r\n    return (x >= 0 && x < this.width) && (y >= 0 && y < this.height);\r\n};\r\n\r\n\r\n/**\r\n * Set whether the node on the given position is walkable.\r\n * NOTE: throws exception if the coordinate is not inside the grid.\r\n * @param {number} x - The x coordinate of the node.\r\n * @param {number} y - The y coordinate of the node.\r\n * @param {boolean} walkable - Whether the position is walkable.\r\n */\r\nGrid.prototype.setWalkableAt = function(x, y, walkable) {\r\n    this.nodes[y][x].walkable = walkable;\r\n};\r\n\r\n\r\n/**\r\n * Get the neighbors of the given node.\r\n *\r\n *     offsets      diagonalOffsets:\r\n *  +---+---+---+    +---+---+---+\r\n *  |   | 0 |   |    | 0 |   | 1 |\r\n *  +---+---+---+    +---+---+---+\r\n *  | 3 |   | 1 |    |   |   |   |\r\n *  +---+---+---+    +---+---+---+\r\n *  |   | 2 |   |    | 3 |   | 2 |\r\n *  +---+---+---+    +---+---+---+\r\n *\r\n *  When allowDiagonal is true, if offsets[i] is valid, then\r\n *  diagonalOffsets[i] and\r\n *  diagonalOffsets[(i + 1) % 4] is valid.\r\n * @param {Node} node\r\n * @param {DiagonalMovement} diagonalMovement\r\n */\r\nGrid.prototype.getNeighbors = function(node, diagonalMovement) {\r\n    var x = node.x,\r\n        y = node.y,\r\n        neighbors = [],\r\n        s0 = false, d0 = false,\r\n        s1 = false, d1 = false,\r\n        s2 = false, d2 = false,\r\n        s3 = false, d3 = false,\r\n        nodes = this.nodes;\r\n\r\n    // ↑\r\n    if (this.isWalkableAt(x, y - 1)) {\r\n        neighbors.push(nodes[y - 1][x]);\r\n        s0 = true;\r\n    }\r\n    // →\r\n    if (this.isWalkableAt(x + 1, y)) {\r\n        neighbors.push(nodes[y][x + 1]);\r\n        s1 = true;\r\n    }\r\n    // ↓\r\n    if (this.isWalkableAt(x, y + 1)) {\r\n        neighbors.push(nodes[y + 1][x]);\r\n        s2 = true;\r\n    }\r\n    // ←\r\n    if (this.isWalkableAt(x - 1, y)) {\r\n        neighbors.push(nodes[y][x - 1]);\r\n        s3 = true;\r\n    }\r\n\r\n    if (diagonalMovement === DiagonalMovement.Never) {\r\n        return neighbors;\r\n    }\r\n\r\n    if (diagonalMovement === DiagonalMovement.OnlyWhenNoObstacles) {\r\n        d0 = s3 && s0;\r\n        d1 = s0 && s1;\r\n        d2 = s1 && s2;\r\n        d3 = s2 && s3;\r\n    } else if (diagonalMovement === DiagonalMovement.IfAtMostOneObstacle) {\r\n        d0 = s3 || s0;\r\n        d1 = s0 || s1;\r\n        d2 = s1 || s2;\r\n        d3 = s2 || s3;\r\n    } else if (diagonalMovement === DiagonalMovement.Always) {\r\n        d0 = true;\r\n        d1 = true;\r\n        d2 = true;\r\n        d3 = true;\r\n    } else {\r\n        throw new Error('Incorrect value of diagonalMovement');\r\n    }\r\n\r\n    // ↖\r\n    if (d0 && this.isWalkableAt(x - 1, y - 1)) {\r\n        neighbors.push(nodes[y - 1][x - 1]);\r\n    }\r\n    // ↗\r\n    if (d1 && this.isWalkableAt(x + 1, y - 1)) {\r\n        neighbors.push(nodes[y - 1][x + 1]);\r\n    }\r\n    // ↘\r\n    if (d2 && this.isWalkableAt(x + 1, y + 1)) {\r\n        neighbors.push(nodes[y + 1][x + 1]);\r\n    }\r\n    // ↙\r\n    if (d3 && this.isWalkableAt(x - 1, y + 1)) {\r\n        neighbors.push(nodes[y + 1][x - 1]);\r\n    }\r\n\r\n    return neighbors;\r\n};\r\n\r\n\r\n/**\r\n * Get a clone of this grid.\r\n * @return {Grid} Cloned grid.\r\n */\r\nGrid.prototype.clone = function() {\r\n    var i, j,\r\n\r\n        width = this.width,\r\n        height = this.height,\r\n        thisNodes = this.nodes,\r\n\r\n        newGrid = new Grid(width, height),\r\n        newNodes = new Array(height);\r\n\r\n    for (i = 0; i < height; ++i) {\r\n        newNodes[i] = new Array(width);\r\n        for (j = 0; j < width; ++j) {\r\n            newNodes[i][j] = new Node(j, i, thisNodes[i][j].walkable);\r\n        }\r\n    }\r\n\r\n    newGrid.nodes = newNodes;\r\n\r\n    return newGrid;\r\n};\r\n\r\nmodule.exports = Grid;\r\n", "/**\r\n * Backtrace according to the parent records and return the path.\r\n * (including both start and end nodes)\r\n * @param {Node} node End node\r\n * @return {Array<Array<number>>} the path\r\n */\r\nfunction backtrace(node) {\r\n    var path = [[node.x, node.y]];\r\n    while (node.parent) {\r\n        node = node.parent;\r\n        path.push([node.x, node.y]);\r\n    }\r\n    return path.reverse();\r\n}\r\nexports.backtrace = backtrace;\r\n\r\n/**\r\n * Backtrace from start and end node, and return the path.\r\n * (including both start and end nodes)\r\n * @param {Node}\r\n * @param {Node}\r\n */\r\nfunction biBacktrace(nodeA, nodeB) {\r\n    var pathA = backtrace(nodeA),\r\n        pathB = backtrace(nodeB);\r\n    return pathA.concat(pathB.reverse());\r\n}\r\nexports.biBacktrace = biBacktrace;\r\n\r\n/**\r\n * Compute the length of the path.\r\n * @param {Array<Array<number>>} path The path\r\n * @return {number} The length of the path\r\n */\r\nfunction pathLength(path) {\r\n    var i, sum = 0, a, b, dx, dy;\r\n    for (i = 1; i < path.length; ++i) {\r\n        a = path[i - 1];\r\n        b = path[i];\r\n        dx = a[0] - b[0];\r\n        dy = a[1] - b[1];\r\n        sum += Math.sqrt(dx * dx + dy * dy);\r\n    }\r\n    return sum;\r\n}\r\nexports.pathLength = pathLength;\r\n\r\n\r\n/**\r\n * Given the start and end coordinates, return all the coordinates lying\r\n * on the line formed by these coordinates, based on Bresenham's algorithm.\r\n * http://en.wikipedia.org/wiki/Bresenham's_line_algorithm#Simplification\r\n * @param {number} x0 Start x coordinate\r\n * @param {number} y0 Start y coordinate\r\n * @param {number} x1 End x coordinate\r\n * @param {number} y1 End y coordinate\r\n * @return {Array<Array<number>>} The coordinates on the line\r\n */\r\nfunction interpolate(x0, y0, x1, y1) {\r\n    var abs = Math.abs,\r\n        line = [],\r\n        sx, sy, dx, dy, err, e2;\r\n\r\n    dx = abs(x1 - x0);\r\n    dy = abs(y1 - y0);\r\n\r\n    sx = (x0 < x1) ? 1 : -1;\r\n    sy = (y0 < y1) ? 1 : -1;\r\n\r\n    err = dx - dy;\r\n\r\n    while (true) {\r\n        line.push([x0, y0]);\r\n\r\n        if (x0 === x1 && y0 === y1) {\r\n            break;\r\n        }\r\n        \r\n        e2 = 2 * err;\r\n        if (e2 > -dy) {\r\n            err = err - dy;\r\n            x0 = x0 + sx;\r\n        }\r\n        if (e2 < dx) {\r\n            err = err + dx;\r\n            y0 = y0 + sy;\r\n        }\r\n    }\r\n\r\n    return line;\r\n}\r\nexports.interpolate = interpolate;\r\n\r\n\r\n/**\r\n * Given a compressed path, return a new path that has all the segments\r\n * in it interpolated.\r\n * @param {Array<Array<number>>} path The path\r\n * @return {Array<Array<number>>} expanded path\r\n */\r\nfunction expandPath(path) {\r\n    var expanded = [],\r\n        len = path.length,\r\n        coord0, coord1,\r\n        interpolated,\r\n        interpolatedLen,\r\n        i, j;\r\n\r\n    if (len < 2) {\r\n        return expanded;\r\n    }\r\n\r\n    for (i = 0; i < len - 1; ++i) {\r\n        coord0 = path[i];\r\n        coord1 = path[i + 1];\r\n\r\n        interpolated = interpolate(coord0[0], coord0[1], coord1[0], coord1[1]);\r\n        interpolatedLen = interpolated.length;\r\n        for (j = 0; j < interpolatedLen - 1; ++j) {\r\n            expanded.push(interpolated[j]);\r\n        }\r\n    }\r\n    expanded.push(path[len - 1]);\r\n\r\n    return expanded;\r\n}\r\nexports.expandPath = expandPath;\r\n\r\n\r\n/**\r\n * Smoothen the give path.\r\n * The original path will not be modified; a new path will be returned.\r\n * @param {PF.Grid} grid\r\n * @param {Array<Array<number>>} path The path\r\n */\r\nfunction smoothenPath(grid, path) {\r\n    var len = path.length,\r\n        x0 = path[0][0],        // path start x\r\n        y0 = path[0][1],        // path start y\r\n        x1 = path[len - 1][0],  // path end x\r\n        y1 = path[len - 1][1],  // path end y\r\n        sx, sy,                 // current start coordinate\r\n        ex, ey,                 // current end coordinate\r\n        newPath,\r\n        i, j, coord, line, testCoord, blocked;\r\n\r\n    sx = x0;\r\n    sy = y0;\r\n    newPath = [[sx, sy]];\r\n\r\n    for (i = 2; i < len; ++i) {\r\n        coord = path[i];\r\n        ex = coord[0];\r\n        ey = coord[1];\r\n        line = interpolate(sx, sy, ex, ey);\r\n\r\n        blocked = false;\r\n        for (j = 1; j < line.length; ++j) {\r\n            testCoord = line[j];\r\n\r\n            if (!grid.isWalkableAt(testCoord[0], testCoord[1])) {\r\n                blocked = true;\r\n                break;\r\n            }\r\n        }\r\n        if (blocked) {\r\n            lastValidCoord = path[i - 1];\r\n            newPath.push(lastValidCoord);\r\n            sx = lastValidCoord[0];\r\n            sy = lastValidCoord[1];\r\n        }\r\n    }\r\n    newPath.push([x1, y1]);\r\n\r\n    return newPath;\r\n}\r\nexports.smoothenPath = smoothenPath;\r\n\r\n\r\n/**\r\n * Compress a path, remove redundant nodes without altering the shape\r\n * The original path is not modified\r\n * @param {Array<Array<number>>} path The path\r\n * @return {Array<Array<number>>} The compressed path\r\n */\r\nfunction compressPath(path) {\r\n\r\n    // nothing to compress\r\n    if(path.length < 3) {\r\n        return path;\r\n    }\r\n\r\n    var compressed = [],\r\n        sx = path[0][0], // start x\r\n        sy = path[0][1], // start y\r\n        px = path[1][0], // second point x\r\n        py = path[1][1], // second point y\r\n        dx = px - sx, // direction between the two points\r\n        dy = py - sy, // direction between the two points\r\n        lx, ly,\r\n        ldx, ldy,\r\n        sq, i;\r\n\r\n    // normalize the direction\r\n    sq = Math.sqrt(dx*dx + dy*dy);\r\n    dx /= sq;\r\n    dy /= sq;\r\n\r\n    // start the new path\r\n    compressed.push([sx,sy]);\r\n\r\n    for(i = 2; i < path.length; i++) {\r\n\r\n        // store the last point\r\n        lx = px;\r\n        ly = py;\r\n\r\n        // store the last direction\r\n        ldx = dx;\r\n        ldy = dy;\r\n\r\n        // next point\r\n        px = path[i][0];\r\n        py = path[i][1];\r\n\r\n        // next direction\r\n        dx = px - lx;\r\n        dy = py - ly;\r\n\r\n        // normalize\r\n        sq = Math.sqrt(dx*dx + dy*dy);\r\n        dx /= sq;\r\n        dy /= sq;\r\n\r\n        // if the direction has changed, store the point\r\n        if ( dx !== ldx || dy !== ldy ) {\r\n            compressed.push([lx,ly]);\r\n        }\r\n    }\r\n\r\n    // store the last point\r\n    compressed.push([px,py]);\r\n\r\n    return compressed;\r\n}\r\nexports.compressPath = compressPath;\r\n", "/**\r\n * @namespace PF.Heuristic\r\n * @description A collection of heuristic functions.\r\n */\r\nmodule.exports = {\r\n\r\n  /**\r\n   * Manhattan distance.\r\n   * @param {number} dx - Difference in x.\r\n   * @param {number} dy - Difference in y.\r\n   * @return {number} dx + dy\r\n   */\r\n  manhattan: function(dx, dy) {\r\n      return dx + dy;\r\n  },\r\n\r\n  /**\r\n   * Euclidean distance.\r\n   * @param {number} dx - Difference in x.\r\n   * @param {number} dy - Difference in y.\r\n   * @return {number} sqrt(dx * dx + dy * dy)\r\n   */\r\n  euclidean: function(dx, dy) {\r\n      return Math.sqrt(dx * dx + dy * dy);\r\n  },\r\n\r\n  /**\r\n   * Octile distance.\r\n   * @param {number} dx - Difference in x.\r\n   * @param {number} dy - Difference in y.\r\n   * @return {number} sqrt(dx * dx + dy * dy) for grids\r\n   */\r\n  octile: function(dx, dy) {\r\n      var F = Math.SQRT2 - 1;\r\n      return (dx < dy) ? F * dx + dy : F * dy + dx;\r\n  },\r\n\r\n  /**\r\n   * Chebyshev distance.\r\n   * @param {number} dx - Difference in x.\r\n   * @param {number} dy - Difference in y.\r\n   * @return {number} max(dx, dy)\r\n   */\r\n  chebyshev: function(dx, dy) {\r\n      return Math.max(dx, dy);\r\n  }\r\n\r\n};\r\n", "var Heap       = require('heap');\r\nvar Util       = require('../core/Util');\r\nvar Heuristic  = require('../core/Heuristic');\r\nvar DiagonalMovement = require('../core/DiagonalMovement');\r\n\r\n/**\r\n * A* path-finder. Based upon https://github.com/bgrins/javascript-astar\r\n * @constructor\r\n * @param {Object} opt\r\n * @param {boolean} opt.allowDiagonal Whether diagonal movement is allowed.\r\n *     Deprecated, use diagonalMovement instead.\r\n * @param {boolean} opt.dontCrossCorners Disallow diagonal movement touching \r\n *     block corners. Deprecated, use diagonalMovement instead.\r\n * @param {DiagonalMovement} opt.diagonalMovement Allowed diagonal movement.\r\n * @param {function} opt.heuristic Heuristic function to estimate the distance\r\n *     (defaults to manhattan).\r\n * @param {number} opt.weight Weight to apply to the heuristic to allow for\r\n *     suboptimal paths, in order to speed up the search.\r\n */\r\nfunction AStarFinder(opt) {\r\n    opt = opt || {};\r\n    this.allowDiagonal = opt.allowDiagonal;\r\n    this.dontCrossCorners = opt.dontCrossCorners;\r\n    this.heuristic = opt.heuristic || Heuristic.manhattan;\r\n    this.weight = opt.weight || 1;\r\n    this.diagonalMovement = opt.diagonalMovement;\r\n\r\n    if (!this.diagonalMovement) {\r\n        if (!this.allowDiagonal) {\r\n            this.diagonalMovement = DiagonalMovement.Never;\r\n        } else {\r\n            if (this.dontCrossCorners) {\r\n                this.diagonalMovement = DiagonalMovement.OnlyWhenNoObstacles;\r\n            } else {\r\n                this.diagonalMovement = DiagonalMovement.IfAtMostOneObstacle;\r\n            }\r\n        }\r\n    }\r\n\r\n    // When diagonal movement is allowed the manhattan heuristic is not\r\n    //admissible. It should be octile instead\r\n    if (this.diagonalMovement === DiagonalMovement.Never) {\r\n        this.heuristic = opt.heuristic || Heuristic.manhattan;\r\n    } else {\r\n        this.heuristic = opt.heuristic || Heuristic.octile;\r\n    }\r\n}\r\n\r\n/**\r\n * Find and return the the path.\r\n * @return {Array<Array<number>>} The path, including both start and\r\n *     end positions.\r\n */\r\nAStarFinder.prototype.findPath = function(startX, startY, endX, endY, grid) {\r\n    var openList = new Heap(function(nodeA, nodeB) {\r\n            return nodeA.f - nodeB.f;\r\n        }),\r\n        startNode = grid.getNodeAt(startX, startY),\r\n        endNode = grid.getNodeAt(endX, endY),\r\n        heuristic = this.heuristic,\r\n        diagonalMovement = this.diagonalMovement,\r\n        weight = this.weight,\r\n        abs = Math.abs, SQRT2 = Math.SQRT2,\r\n        node, neighbors, neighbor, i, l, x, y, ng;\r\n\r\n    // set the `g` and `f` value of the start node to be 0\r\n    startNode.g = 0;\r\n    startNode.f = 0;\r\n\r\n    // push the start node into the open list\r\n    openList.push(startNode);\r\n    startNode.opened = true;\r\n\r\n    // while the open list is not empty\r\n    while (!openList.empty()) {\r\n        // pop the position of node which has the minimum `f` value.\r\n        node = openList.pop();\r\n        node.closed = true;\r\n\r\n        // if reached the end position, construct the path and return it\r\n        if (node === endNode) {\r\n            return Util.backtrace(endNode);\r\n        }\r\n\r\n        // get neigbours of the current node\r\n        neighbors = grid.getNeighbors(node, diagonalMovement);\r\n        for (i = 0, l = neighbors.length; i < l; ++i) {\r\n            neighbor = neighbors[i];\r\n\r\n            if (neighbor.closed) {\r\n                continue;\r\n            }\r\n\r\n            x = neighbor.x;\r\n            y = neighbor.y;\r\n\r\n            // get the distance between current node and the neighbor\r\n            // and calculate the next g score\r\n            ng = node.g + ((x - node.x === 0 || y - node.y === 0) ? 1 : SQRT2);\r\n\r\n            // check if the neighbor has not been inspected yet, or\r\n            // can be reached with smaller cost from the current node\r\n            if (!neighbor.opened || ng < neighbor.g) {\r\n                neighbor.g = ng;\r\n                neighbor.h = neighbor.h || weight * heuristic(abs(x - endX), abs(y - endY));\r\n                neighbor.f = neighbor.g + neighbor.h;\r\n                neighbor.parent = node;\r\n\r\n                if (!neighbor.opened) {\r\n                    openList.push(neighbor);\r\n                    neighbor.opened = true;\r\n                } else {\r\n                    // the neighbor can be reached with smaller cost.\r\n                    // Since its f value has been updated, we have to\r\n                    // update its position in the open list\r\n                    openList.updateItem(neighbor);\r\n                }\r\n            }\r\n        } // end for each neighbor\r\n    } // end while not open list empty\r\n\r\n    // fail to find the path\r\n    return [];\r\n};\r\n\r\nmodule.exports = AStarFinder;\r\n", "var AStarFinder = require('./AStarFinder');\r\n\r\n/**\r\n * Best-First-Search path-finder.\r\n * @constructor\r\n * @extends AStarFinder\r\n * @param {Object} opt\r\n * @param {boolean} opt.allowDiagonal Whether diagonal movement is allowed.\r\n *     Deprecated, use diagonalMovement instead.\r\n * @param {boolean} opt.dontCrossCorners Disallow diagonal movement touching\r\n *     block corners. Deprecated, use diagonalMovement instead.\r\n * @param {DiagonalMovement} opt.diagonalMovement Allowed diagonal movement.\r\n * @param {function} opt.heuristic Heuristic function to estimate the distance\r\n *     (defaults to manhattan).\r\n */\r\nfunction BestFirstFinder(opt) {\r\n    AStarFinder.call(this, opt);\r\n\r\n    var orig = this.heuristic;\r\n    this.heuristic = function(dx, dy) {\r\n        return orig(dx, dy) * 1000000;\r\n    };\r\n}\r\n\r\nBestFirstFinder.prototype = new AStarFinder();\r\nBestFirstFinder.prototype.constructor = BestFirstFinder;\r\n\r\nmodule.exports = BestFirstFinder;\r\n", "var Util = require('../core/Util');\r\nvar DiagonalMovement = require('../core/DiagonalMovement');\r\n\r\n/**\r\n * Breadth-First-Search path finder.\r\n * @constructor\r\n * @param {Object} opt\r\n * @param {boolean} opt.allowDiagonal Whether diagonal movement is allowed.\r\n *     Deprecated, use diagonalMovement instead.\r\n * @param {boolean} opt.dontCrossCorners Disallow diagonal movement touching\r\n *     block corners. Deprecated, use diagonalMovement instead.\r\n * @param {DiagonalMovement} opt.diagonalMovement Allowed diagonal movement.\r\n */\r\nfunction BreadthFirstFinder(opt) {\r\n    opt = opt || {};\r\n    this.allowDiagonal = opt.allowDiagonal;\r\n    this.dontCrossCorners = opt.dontCrossCorners;\r\n    this.diagonalMovement = opt.diagonalMovement;\r\n\r\n    if (!this.diagonalMovement) {\r\n        if (!this.allowDiagonal) {\r\n            this.diagonalMovement = DiagonalMovement.Never;\r\n        } else {\r\n            if (this.dontCrossCorners) {\r\n                this.diagonalMovement = DiagonalMovement.OnlyWhenNoObstacles;\r\n            } else {\r\n                this.diagonalMovement = DiagonalMovement.IfAtMostOneObstacle;\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * Find and return the the path.\r\n * @return {Array<Array<number>>} The path, including both start and\r\n *     end positions.\r\n */\r\nBreadthFirstFinder.prototype.findPath = function(startX, startY, endX, endY, grid) {\r\n    var openList = [],\r\n        diagonalMovement = this.diagonalMovement,\r\n        startNode = grid.getNodeAt(startX, startY),\r\n        endNode = grid.getNodeAt(endX, endY),\r\n        neighbors, neighbor, node, i, l;\r\n\r\n    // push the start pos into the queue\r\n    openList.push(startNode);\r\n    startNode.opened = true;\r\n\r\n    // while the queue is not empty\r\n    while (openList.length) {\r\n        // take the front node from the queue\r\n        node = openList.shift();\r\n        node.closed = true;\r\n\r\n        // reached the end position\r\n        if (node === endNode) {\r\n            return Util.backtrace(endNode);\r\n        }\r\n\r\n        neighbors = grid.getNeighbors(node, diagonalMovement);\r\n        for (i = 0, l = neighbors.length; i < l; ++i) {\r\n            neighbor = neighbors[i];\r\n\r\n            // skip this neighbor if it has been inspected before\r\n            if (neighbor.closed || neighbor.opened) {\r\n                continue;\r\n            }\r\n\r\n            openList.push(neighbor);\r\n            neighbor.opened = true;\r\n            neighbor.parent = node;\r\n        }\r\n    }\r\n    \r\n    // fail to find the path\r\n    return [];\r\n};\r\n\r\nmodule.exports = BreadthFirstFinder;\r\n", "var AStarFinder = require('./AStarFinder');\r\n\r\n/**\r\n * Dijkstra path-finder.\r\n * @constructor\r\n * @extends AStarFinder\r\n * @param {Object} opt\r\n * @param {boolean} opt.allowDiagonal Whether diagonal movement is allowed.\r\n *     Deprecated, use diagonalMovement instead.\r\n * @param {boolean} opt.dontCrossCorners Disallow diagonal movement touching\r\n *     block corners. Deprecated, use diagonalMovement instead.\r\n * @param {DiagonalMovement} opt.diagonalMovement Allowed diagonal movement.\r\n */\r\nfunction DijkstraFinder(opt) {\r\n    AStarFinder.call(this, opt);\r\n    this.heuristic = function(dx, dy) {\r\n        return 0;\r\n    };\r\n}\r\n\r\nDijkstraFinder.prototype = new AStarFinder();\r\nDijkstraFinder.prototype.constructor = DijkstraFinder;\r\n\r\nmodule.exports = DijkstraFinder;\r\n", "var Heap       = require('heap');\r\nvar Util       = require('../core/Util');\r\nvar Heuristic  = require('../core/Heuristic');\r\nvar DiagonalMovement = require('../core/DiagonalMovement');\r\n\r\n/**\r\n * A* path-finder.\r\n * based upon https://github.com/bgrins/javascript-astar\r\n * @constructor\r\n * @param {Object} opt\r\n * @param {boolean} opt.allowDiagonal Whether diagonal movement is allowed.\r\n *     Deprecated, use diagonalMovement instead.\r\n * @param {boolean} opt.dontCrossCorners Disallow diagonal movement touching\r\n *     block corners. Deprecated, use diagonalMovement instead.\r\n * @param {DiagonalMovement} opt.diagonalMovement Allowed diagonal movement.\r\n * @param {function} opt.heuristic Heuristic function to estimate the distance\r\n *     (defaults to manhattan).\r\n * @param {number} opt.weight Weight to apply to the heuristic to allow for\r\n *     suboptimal paths, in order to speed up the search.\r\n */\r\nfunction BiAStarFinder(opt) {\r\n    opt = opt || {};\r\n    this.allowDiagonal = opt.allowDiagonal;\r\n    this.dontCrossCorners = opt.dontCrossCorners;\r\n    this.diagonalMovement = opt.diagonalMovement;\r\n    this.heuristic = opt.heuristic || Heuristic.manhattan;\r\n    this.weight = opt.weight || 1;\r\n\r\n    if (!this.diagonalMovement) {\r\n        if (!this.allowDiagonal) {\r\n            this.diagonalMovement = DiagonalMovement.Never;\r\n        } else {\r\n            if (this.dontCrossCorners) {\r\n                this.diagonalMovement = DiagonalMovement.OnlyWhenNoObstacles;\r\n            } else {\r\n                this.diagonalMovement = DiagonalMovement.IfAtMostOneObstacle;\r\n            }\r\n        }\r\n    }\r\n\r\n    //When diagonal movement is allowed the manhattan heuristic is not admissible\r\n    //It should be octile instead\r\n    if (this.diagonalMovement === DiagonalMovement.Never) {\r\n        this.heuristic = opt.heuristic || Heuristic.manhattan;\r\n    } else {\r\n        this.heuristic = opt.heuristic || Heuristic.octile;\r\n    }\r\n}\r\n\r\n/**\r\n * Find and return the the path.\r\n * @return {Array<Array<number>>} The path, including both start and\r\n *     end positions.\r\n */\r\nBiAStarFinder.prototype.findPath = function(startX, startY, endX, endY, grid) {\r\n    var cmp = function(nodeA, nodeB) {\r\n            return nodeA.f - nodeB.f;\r\n        },\r\n        startOpenList = new Heap(cmp),\r\n        endOpenList = new Heap(cmp),\r\n        startNode = grid.getNodeAt(startX, startY),\r\n        endNode = grid.getNodeAt(endX, endY),\r\n        heuristic = this.heuristic,\r\n        diagonalMovement = this.diagonalMovement,\r\n        weight = this.weight,\r\n        abs = Math.abs, SQRT2 = Math.SQRT2,\r\n        node, neighbors, neighbor, i, l, x, y, ng,\r\n        BY_START = 1, BY_END = 2;\r\n\r\n    // set the `g` and `f` value of the start node to be 0\r\n    // and push it into the start open list\r\n    startNode.g = 0;\r\n    startNode.f = 0;\r\n    startOpenList.push(startNode);\r\n    startNode.opened = BY_START;\r\n\r\n    // set the `g` and `f` value of the end node to be 0\r\n    // and push it into the open open list\r\n    endNode.g = 0;\r\n    endNode.f = 0;\r\n    endOpenList.push(endNode);\r\n    endNode.opened = BY_END;\r\n\r\n    // while both the open lists are not empty\r\n    while (!startOpenList.empty() && !endOpenList.empty()) {\r\n\r\n        // pop the position of start node which has the minimum `f` value.\r\n        node = startOpenList.pop();\r\n        node.closed = true;\r\n\r\n        // get neigbours of the current node\r\n        neighbors = grid.getNeighbors(node, diagonalMovement);\r\n        for (i = 0, l = neighbors.length; i < l; ++i) {\r\n            neighbor = neighbors[i];\r\n\r\n            if (neighbor.closed) {\r\n                continue;\r\n            }\r\n            if (neighbor.opened === BY_END) {\r\n                return Util.biBacktrace(node, neighbor);\r\n            }\r\n\r\n            x = neighbor.x;\r\n            y = neighbor.y;\r\n\r\n            // get the distance between current node and the neighbor\r\n            // and calculate the next g score\r\n            ng = node.g + ((x - node.x === 0 || y - node.y === 0) ? 1 : SQRT2);\r\n\r\n            // check if the neighbor has not been inspected yet, or\r\n            // can be reached with smaller cost from the current node\r\n            if (!neighbor.opened || ng < neighbor.g) {\r\n                neighbor.g = ng;\r\n                neighbor.h = neighbor.h ||\r\n                    weight * heuristic(abs(x - endX), abs(y - endY));\r\n                neighbor.f = neighbor.g + neighbor.h;\r\n                neighbor.parent = node;\r\n\r\n                if (!neighbor.opened) {\r\n                    startOpenList.push(neighbor);\r\n                    neighbor.opened = BY_START;\r\n                } else {\r\n                    // the neighbor can be reached with smaller cost.\r\n                    // Since its f value has been updated, we have to\r\n                    // update its position in the open list\r\n                    startOpenList.updateItem(neighbor);\r\n                }\r\n            }\r\n        } // end for each neighbor\r\n\r\n\r\n        // pop the position of end node which has the minimum `f` value.\r\n        node = endOpenList.pop();\r\n        node.closed = true;\r\n\r\n        // get neigbours of the current node\r\n        neighbors = grid.getNeighbors(node, diagonalMovement);\r\n        for (i = 0, l = neighbors.length; i < l; ++i) {\r\n            neighbor = neighbors[i];\r\n\r\n            if (neighbor.closed) {\r\n                continue;\r\n            }\r\n            if (neighbor.opened === BY_START) {\r\n                return Util.biBacktrace(neighbor, node);\r\n            }\r\n\r\n            x = neighbor.x;\r\n            y = neighbor.y;\r\n\r\n            // get the distance between current node and the neighbor\r\n            // and calculate the next g score\r\n            ng = node.g + ((x - node.x === 0 || y - node.y === 0) ? 1 : SQRT2);\r\n\r\n            // check if the neighbor has not been inspected yet, or\r\n            // can be reached with smaller cost from the current node\r\n            if (!neighbor.opened || ng < neighbor.g) {\r\n                neighbor.g = ng;\r\n                neighbor.h = neighbor.h ||\r\n                    weight * heuristic(abs(x - startX), abs(y - startY));\r\n                neighbor.f = neighbor.g + neighbor.h;\r\n                neighbor.parent = node;\r\n\r\n                if (!neighbor.opened) {\r\n                    endOpenList.push(neighbor);\r\n                    neighbor.opened = BY_END;\r\n                } else {\r\n                    // the neighbor can be reached with smaller cost.\r\n                    // Since its f value has been updated, we have to\r\n                    // update its position in the open list\r\n                    endOpenList.updateItem(neighbor);\r\n                }\r\n            }\r\n        } // end for each neighbor\r\n    } // end while not open list empty\r\n\r\n    // fail to find the path\r\n    return [];\r\n};\r\n\r\nmodule.exports = BiAStarFinder;\r\n", "var BiAStarFinder = require('./BiAStarFinder');\r\n\r\n/**\r\n * Bi-direcitional Best-First-Search path-finder.\r\n * @constructor\r\n * @extends BiAStarFinder\r\n * @param {Object} opt\r\n * @param {boolean} opt.allowDiagonal Whether diagonal movement is allowed.\r\n *     Deprecated, use diagonalMovement instead.\r\n * @param {boolean} opt.dontCrossCorners Disallow diagonal movement touching\r\n *     block corners. Deprecated, use diagonalMovement instead.\r\n * @param {DiagonalMovement} opt.diagonalMovement Allowed diagonal movement.\r\n * @param {function} opt.heuristic Heuristic function to estimate the distance\r\n *     (defaults to manhattan).\r\n */\r\nfunction BiBestFirstFinder(opt) {\r\n    BiAStarFinder.call(this, opt);\r\n\r\n    var orig = this.heuristic;\r\n    this.heuristic = function(dx, dy) {\r\n        return orig(dx, dy) * 1000000;\r\n    };\r\n}\r\n\r\nBiBestFirstFinder.prototype = new BiAStarFinder();\r\nBiBestFirstFinder.prototype.constructor = BiBestFirstFinder;\r\n\r\nmodule.exports = BiBestFirstFinder;\r\n", "var Util = require('../core/Util');\r\nvar DiagonalMovement = require('../core/DiagonalMovement');\r\n\r\n/**\r\n * Bi-directional Breadth-First-Search path finder.\r\n * @constructor\r\n * @param {object} opt\r\n * @param {boolean} opt.allowDiagonal Whether diagonal movement is allowed.\r\n *     Deprecated, use diagonalMovement instead.\r\n * @param {boolean} opt.dontCrossCorners Disallow diagonal movement touching\r\n *     block corners. Deprecated, use diagonalMovement instead.\r\n * @param {DiagonalMovement} opt.diagonalMovement Allowed diagonal movement.\r\n */\r\nfunction BiBreadthFirstFinder(opt) {\r\n    opt = opt || {};\r\n    this.allowDiagonal = opt.allowDiagonal;\r\n    this.dontCrossCorners = opt.dontCrossCorners;\r\n    this.diagonalMovement = opt.diagonalMovement;\r\n\r\n    if (!this.diagonalMovement) {\r\n        if (!this.allowDiagonal) {\r\n            this.diagonalMovement = DiagonalMovement.Never;\r\n        } else {\r\n            if (this.dontCrossCorners) {\r\n                this.diagonalMovement = DiagonalMovement.OnlyWhenNoObstacles;\r\n            } else {\r\n                this.diagonalMovement = DiagonalMovement.IfAtMostOneObstacle;\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * Find and return the the path.\r\n * @return {Array<Array<number>>} The path, including both start and\r\n *     end positions.\r\n */\r\nBiBreadthFirstFinder.prototype.findPath = function(startX, startY, endX, endY, grid) {\r\n    var startNode = grid.getNodeAt(startX, startY),\r\n        endNode = grid.getNodeAt(endX, endY),\r\n        startOpenList = [], endOpenList = [],\r\n        neighbors, neighbor, node,\r\n        diagonalMovement = this.diagonalMovement,\r\n        BY_START = 0, BY_END = 1,\r\n        i, l;\r\n\r\n    // push the start and end nodes into the queues\r\n    startOpenList.push(startNode);\r\n    startNode.opened = true;\r\n    startNode.by = BY_START;\r\n\r\n    endOpenList.push(endNode);\r\n    endNode.opened = true;\r\n    endNode.by = BY_END;\r\n\r\n    // while both the queues are not empty\r\n    while (startOpenList.length && endOpenList.length) {\r\n\r\n        // expand start open list\r\n\r\n        node = startOpenList.shift();\r\n        node.closed = true;\r\n\r\n        neighbors = grid.getNeighbors(node, diagonalMovement);\r\n        for (i = 0, l = neighbors.length; i < l; ++i) {\r\n            neighbor = neighbors[i];\r\n\r\n            if (neighbor.closed) {\r\n                continue;\r\n            }\r\n            if (neighbor.opened) {\r\n                // if this node has been inspected by the reversed search,\r\n                // then a path is found.\r\n                if (neighbor.by === BY_END) {\r\n                    return Util.biBacktrace(node, neighbor);\r\n                }\r\n                continue;\r\n            }\r\n            startOpenList.push(neighbor);\r\n            neighbor.parent = node;\r\n            neighbor.opened = true;\r\n            neighbor.by = BY_START;\r\n        }\r\n\r\n        // expand end open list\r\n\r\n        node = endOpenList.shift();\r\n        node.closed = true;\r\n\r\n        neighbors = grid.getNeighbors(node, diagonalMovement);\r\n        for (i = 0, l = neighbors.length; i < l; ++i) {\r\n            neighbor = neighbors[i];\r\n\r\n            if (neighbor.closed) {\r\n                continue;\r\n            }\r\n            if (neighbor.opened) {\r\n                if (neighbor.by === BY_START) {\r\n                    return Util.biBacktrace(neighbor, node);\r\n                }\r\n                continue;\r\n            }\r\n            endOpenList.push(neighbor);\r\n            neighbor.parent = node;\r\n            neighbor.opened = true;\r\n            neighbor.by = BY_END;\r\n        }\r\n    }\r\n\r\n    // fail to find the path\r\n    return [];\r\n};\r\n\r\nmodule.exports = BiBreadthFirstFinder;\r\n", "var BiAStarFinder = require('./BiAStarFinder');\r\n\r\n/**\r\n * Bi-directional Dijkstra path-finder.\r\n * @constructor\r\n * @extends BiAStarFinder\r\n * @param {Object} opt\r\n * @param {boolean} opt.allowDiagonal Whether diagonal movement is allowed.\r\n *     Deprecated, use diagonalMovement instead.\r\n * @param {boolean} opt.dontCrossCorners Disallow diagonal movement touching\r\n *     block corners. Deprecated, use diagonalMovement instead.\r\n * @param {DiagonalMovement} opt.diagonalMovement Allowed diagonal movement.\r\n */\r\nfunction BiDijkstraFinder(opt) {\r\n    BiAStarFinder.call(this, opt);\r\n    this.heuristic = function(dx, dy) {\r\n        return 0;\r\n    };\r\n}\r\n\r\nBiDijkstraFinder.prototype = new BiAStarFinder();\r\nBiDijkstraFinder.prototype.constructor = BiDijkstraFinder;\r\n\r\nmodule.exports = BiDijkstraFinder;\r\n", "var Util       = require('../core/Util');\r\nvar Heuristic  = require('../core/Heuristic');\r\nvar Node       = require('../core/Node');\r\nvar DiagonalMovement = require('../core/DiagonalMovement');\r\n\r\n/**\r\n * Iterative Deeping A Star (IDA*) path-finder.\r\n *\r\n * Recursion based on:\r\n *   http://www.apl.jhu.edu/~hall/AI-Programming/IDA-Star.html\r\n *\r\n * Path retracing based on:\r\n *  V. Nageshwara Rao, Vipin Kumar and K. Ramesh\r\n *  \"A Parallel Implementation of Iterative-Deeping-A*\", January 1987.\r\n *  ftp://ftp.cs.utexas.edu/.snapshot/hourly.1/pub/AI-Lab/tech-reports/UT-AI-TR-87-46.pdf\r\n *\r\n * @author Gerard Meier (www.gerardmeier.com)\r\n *\r\n * @constructor\r\n * @param {Object} opt\r\n * @param {boolean} opt.allowDiagonal Whether diagonal movement is allowed.\r\n *     Deprecated, use diagonalMovement instead.\r\n * @param {boolean} opt.dontCrossCorners Disallow diagonal movement touching\r\n *     block corners. Deprecated, use diagonalMovement instead.\r\n * @param {DiagonalMovement} opt.diagonalMovement Allowed diagonal movement.\r\n * @param {function} opt.heuristic Heuristic function to estimate the distance\r\n *     (defaults to manhattan).\r\n * @param {number} opt.weight Weight to apply to the heuristic to allow for\r\n *     suboptimal paths, in order to speed up the search.\r\n * @param {boolean} opt.trackRecursion Whether to track recursion for\r\n *     statistical purposes.\r\n * @param {number} opt.timeLimit Maximum execution time. Use <= 0 for infinite.\r\n */\r\nfunction IDAStarFinder(opt) {\r\n    opt = opt || {};\r\n    this.allowDiagonal = opt.allowDiagonal;\r\n    this.dontCrossCorners = opt.dontCrossCorners;\r\n    this.diagonalMovement = opt.diagonalMovement;\r\n    this.heuristic = opt.heuristic || Heuristic.manhattan;\r\n    this.weight = opt.weight || 1;\r\n    this.trackRecursion = opt.trackRecursion || false;\r\n    this.timeLimit = opt.timeLimit || Infinity; // Default: no time limit.\r\n\r\n    if (!this.diagonalMovement) {\r\n        if (!this.allowDiagonal) {\r\n            this.diagonalMovement = DiagonalMovement.Never;\r\n        } else {\r\n            if (this.dontCrossCorners) {\r\n                this.diagonalMovement = DiagonalMovement.OnlyWhenNoObstacles;\r\n            } else {\r\n                this.diagonalMovement = DiagonalMovement.IfAtMostOneObstacle;\r\n            }\r\n        }\r\n    }\r\n\r\n    // When diagonal movement is allowed the manhattan heuristic is not\r\n    // admissible, it should be octile instead\r\n    if (this.diagonalMovement === DiagonalMovement.Never) {\r\n        this.heuristic = opt.heuristic || Heuristic.manhattan;\r\n    } else {\r\n        this.heuristic = opt.heuristic || Heuristic.octile;\r\n    }\r\n}\r\n\r\n/**\r\n * Find and return the the path. When an empty array is returned, either\r\n * no path is possible, or the maximum execution time is reached.\r\n *\r\n * @return {Array<Array<number>>} The path, including both start and\r\n *     end positions.\r\n */\r\nIDAStarFinder.prototype.findPath = function(startX, startY, endX, endY, grid) {\r\n    // Used for statistics:\r\n    var nodesVisited = 0;\r\n\r\n    // Execution time limitation:\r\n    var startTime = new Date().getTime();\r\n\r\n    // Heuristic helper:\r\n    var h = function(a, b) {\r\n        return this.heuristic(Math.abs(b.x - a.x), Math.abs(b.y - a.y));\r\n    }.bind(this);\r\n\r\n    // Step cost from a to b:\r\n    var cost = function(a, b) {\r\n        return (a.x === b.x || a.y === b.y) ? 1 : Math.SQRT2;\r\n    };\r\n\r\n    /**\r\n     * IDA* search implementation.\r\n     *\r\n     * @param {Node} The node currently expanding from.\r\n     * @param {number} Cost to reach the given node.\r\n     * @param {number} Maximum search depth (cut-off value).\r\n     * @param {Array<Array<number>>} The found route.\r\n     * @param {number} Recursion depth.\r\n     *\r\n     * @return {Object} either a number with the new optimal cut-off depth,\r\n     * or a valid node instance, in which case a path was found.\r\n     */\r\n    var search = function(node, g, cutoff, route, depth) {\r\n        nodesVisited++;\r\n\r\n        // Enforce timelimit:\r\n        if (this.timeLimit > 0 &&\r\n            new Date().getTime() - startTime > this.timeLimit * 1000) {\r\n            // Enforced as \"path-not-found\".\r\n            return Infinity;\r\n        }\r\n\r\n        var f = g + h(node, end) * this.weight;\r\n\r\n        // We've searched too deep for this iteration.\r\n        if (f > cutoff) {\r\n            return f;\r\n        }\r\n\r\n        if (node == end) {\r\n            route[depth] = [node.x, node.y];\r\n            return node;\r\n        }\r\n\r\n        var min, t, k, neighbour;\r\n\r\n        var neighbours = grid.getNeighbors(node, this.diagonalMovement);\r\n\r\n        // Sort the neighbours, gives nicer paths. But, this deviates\r\n        // from the original algorithm - so I left it out.\r\n        //neighbours.sort(function(a, b){\r\n        //    return h(a, end) - h(b, end);\r\n        //});\r\n\r\n        \r\n        /*jshint -W084 *///Disable warning: Expected a conditional expression and instead saw an assignment\r\n        for (k = 0, min = Infinity; neighbour = neighbours[k]; ++k) {\r\n        /*jshint +W084 *///Enable warning: Expected a conditional expression and instead saw an assignment\r\n            if (this.trackRecursion) {\r\n                // Retain a copy for visualisation. Due to recursion, this\r\n                // node may be part of other paths too.\r\n                neighbour.retainCount = neighbour.retainCount + 1 || 1;\r\n\r\n                if(neighbour.tested !== true) {\r\n                    neighbour.tested = true;\r\n                }\r\n            }\r\n\r\n            t = search(neighbour, g + cost(node, neighbour), cutoff, route, depth + 1);\r\n\r\n            if (t instanceof Node) {\r\n                route[depth] = [node.x, node.y];\r\n\r\n                // For a typical A* linked list, this would work:\r\n                // neighbour.parent = node;\r\n                return t;\r\n            }\r\n\r\n            // Decrement count, then determine whether it's actually closed.\r\n            if (this.trackRecursion && (--neighbour.retainCount) === 0) {\r\n                neighbour.tested = false;\r\n            }\r\n\r\n            if (t < min) {\r\n                min = t;\r\n            }\r\n        }\r\n\r\n        return min;\r\n\r\n    }.bind(this);\r\n\r\n    // Node instance lookups:\r\n    var start = grid.getNodeAt(startX, startY);\r\n    var end   = grid.getNodeAt(endX, endY);\r\n\r\n    // Initial search depth, given the typical heuristic contraints,\r\n    // there should be no cheaper route possible.\r\n    var cutOff = h(start, end);\r\n\r\n    var j, route, t;\r\n\r\n    // With an overflow protection.\r\n    for (j = 0; true; ++j) {\r\n\r\n        route = [];\r\n\r\n        // Search till cut-off depth:\r\n        t = search(start, 0, cutOff, route, 0);\r\n\r\n        // Route not possible, or not found in time limit.\r\n        if (t === Infinity) {\r\n            return [];\r\n        }\r\n\r\n        // If t is a node, it's also the end node. Route is now\r\n        // populated with a valid path to the end node.\r\n        if (t instanceof Node) {\r\n            return route;\r\n        }\r\n\r\n        // Try again, this time with a deeper cut-off. The t score\r\n        // is the closest we got to the end node.\r\n        cutOff = t;\r\n    }\r\n\r\n    // This _should_ never to be reached.\r\n    return [];\r\n};\r\n\r\nmodule.exports = IDAStarFinder;\r\n", "/**\r\n * @author imor / https://github.com/imor\r\n */\r\nvar Heap       = require('heap');\r\nvar Util       = require('../core/Util');\r\nvar Heuristic  = require('../core/Heuristic');\r\nvar DiagonalMovement = require('../core/DiagonalMovement');\r\n\r\n/**\r\n * Base class for the Jump Point Search algorithm\r\n * @param {object} opt\r\n * @param {function} opt.heuristic Heuristic function to estimate the distance\r\n *     (defaults to manhattan).\r\n */\r\nfunction JumpPointFinderBase(opt) {\r\n    opt = opt || {};\r\n    this.heuristic = opt.heuristic || Heuristic.manhattan;\r\n    this.trackJumpRecursion = opt.trackJumpRecursion || false;\r\n}\r\n\r\n/**\r\n * Find and return the path.\r\n * @return {Array<Array<number>>} The path, including both start and\r\n *     end positions.\r\n */\r\nJumpPointFinderBase.prototype.findPath = function(startX, startY, endX, endY, grid) {\r\n    var openList = this.openList = new Heap(function(nodeA, nodeB) {\r\n            return nodeA.f - nodeB.f;\r\n        }),\r\n        startNode = this.startNode = grid.getNodeAt(startX, startY),\r\n        endNode = this.endNode = grid.getNodeAt(endX, endY), node;\r\n\r\n    this.grid = grid;\r\n\r\n\r\n    // set the `g` and `f` value of the start node to be 0\r\n    startNode.g = 0;\r\n    startNode.f = 0;\r\n\r\n    // push the start node into the open list\r\n    openList.push(startNode);\r\n    startNode.opened = true;\r\n\r\n    // while the open list is not empty\r\n    while (!openList.empty()) {\r\n        // pop the position of node which has the minimum `f` value.\r\n        node = openList.pop();\r\n        node.closed = true;\r\n\r\n        if (node === endNode) {\r\n            return Util.expandPath(Util.backtrace(endNode));\r\n        }\r\n\r\n        this._identifySuccessors(node);\r\n    }\r\n\r\n    // fail to find the path\r\n    return [];\r\n};\r\n\r\n/**\r\n * Identify successors for the given node. Runs a jump point search in the\r\n * direction of each available neighbor, adding any points found to the open\r\n * list.\r\n * @protected\r\n */\r\nJumpPointFinderBase.prototype._identifySuccessors = function(node) {\r\n    var grid = this.grid,\r\n        heuristic = this.heuristic,\r\n        openList = this.openList,\r\n        endX = this.endNode.x,\r\n        endY = this.endNode.y,\r\n        neighbors, neighbor,\r\n        jumpPoint, i, l,\r\n        x = node.x, y = node.y,\r\n        jx, jy, dx, dy, d, ng, jumpNode,\r\n        abs = Math.abs, max = Math.max;\r\n\r\n    neighbors = this._findNeighbors(node);\r\n    for(i = 0, l = neighbors.length; i < l; ++i) {\r\n        neighbor = neighbors[i];\r\n        jumpPoint = this._jump(neighbor[0], neighbor[1], x, y);\r\n        if (jumpPoint) {\r\n\r\n            jx = jumpPoint[0];\r\n            jy = jumpPoint[1];\r\n            jumpNode = grid.getNodeAt(jx, jy);\r\n\r\n            if (jumpNode.closed) {\r\n                continue;\r\n            }\r\n\r\n            // include distance, as parent may not be immediately adjacent:\r\n            d = Heuristic.octile(abs(jx - x), abs(jy - y));\r\n            ng = node.g + d; // next `g` value\r\n\r\n            if (!jumpNode.opened || ng < jumpNode.g) {\r\n                jumpNode.g = ng;\r\n                jumpNode.h = jumpNode.h || heuristic(abs(jx - endX), abs(jy - endY));\r\n                jumpNode.f = jumpNode.g + jumpNode.h;\r\n                jumpNode.parent = node;\r\n\r\n                if (!jumpNode.opened) {\r\n                    openList.push(jumpNode);\r\n                    jumpNode.opened = true;\r\n                } else {\r\n                    openList.updateItem(jumpNode);\r\n                }\r\n            }\r\n        }\r\n    }\r\n};\r\n\r\nmodule.exports = JumpPointFinderBase;\r\n", "/**\r\n * @author imor / https://github.com/imor\r\n */\r\nvar JumpPointFinderBase = require('./JumpPointFinderBase');\r\nvar DiagonalMovement = require('../core/DiagonalMovement');\r\n\r\n/**\r\n * Path finder using the Jump Point Search algorithm allowing only horizontal\r\n * or vertical movements.\r\n */\r\nfunction JPFNeverMoveDiagonally(opt) {\r\n    JumpPointFinderBase.call(this, opt);\r\n}\r\n\r\nJPFNeverMoveDiagonally.prototype = new JumpPointFinderBase();\r\nJPFNeverMoveDiagonally.prototype.constructor = JPFNeverMoveDiagonally;\r\n\r\n/**\r\n * Search recursively in the direction (parent -> child), stopping only when a\r\n * jump point is found.\r\n * @protected\r\n * @return {Array<Array<number>>} The x, y coordinate of the jump point\r\n *     found, or null if not found\r\n */\r\nJPFNeverMoveDiagonally.prototype._jump = function(x, y, px, py) {\r\n    var grid = this.grid,\r\n        dx = x - px, dy = y - py;\r\n\r\n    if (!grid.isWalkableAt(x, y)) {\r\n        return null;\r\n    }\r\n\r\n    if(this.trackJumpRecursion === true) {\r\n        grid.getNodeAt(x, y).tested = true;\r\n    }\r\n\r\n    if (grid.getNodeAt(x, y) === this.endNode) {\r\n        return [x, y];\r\n    }\r\n\r\n    if (dx !== 0) {\r\n        if ((grid.isWalkableAt(x, y - 1) && !grid.isWalkableAt(x - dx, y - 1)) ||\r\n            (grid.isWalkableAt(x, y + 1) && !grid.isWalkableAt(x - dx, y + 1))) {\r\n            return [x, y];\r\n        }\r\n    }\r\n    else if (dy !== 0) {\r\n        if ((grid.isWalkableAt(x - 1, y) && !grid.isWalkableAt(x - 1, y - dy)) ||\r\n            (grid.isWalkableAt(x + 1, y) && !grid.isWalkableAt(x + 1, y - dy))) {\r\n            return [x, y];\r\n        }\r\n        //When moving vertically, must check for horizontal jump points\r\n        if (this._jump(x + 1, y, x, y) || this._jump(x - 1, y, x, y)) {\r\n            return [x, y];\r\n        }\r\n    }\r\n    else {\r\n        throw new Error(\"Only horizontal and vertical movements are allowed\");\r\n    }\r\n\r\n    return this._jump(x + dx, y + dy, x, y);\r\n};\r\n\r\n/**\r\n * Find the neighbors for the given node. If the node has a parent,\r\n * prune the neighbors based on the jump point search algorithm, otherwise\r\n * return all available neighbors.\r\n * @return {Array<Array<number>>} The neighbors found.\r\n */\r\nJPFNeverMoveDiagonally.prototype._findNeighbors = function(node) {\r\n    var parent = node.parent,\r\n        x = node.x, y = node.y,\r\n        grid = this.grid,\r\n        px, py, nx, ny, dx, dy,\r\n        neighbors = [], neighborNodes, neighborNode, i, l;\r\n\r\n    // directed pruning: can ignore most neighbors, unless forced.\r\n    if (parent) {\r\n        px = parent.x;\r\n        py = parent.y;\r\n        // get the normalized direction of travel\r\n        dx = (x - px) / Math.max(Math.abs(x - px), 1);\r\n        dy = (y - py) / Math.max(Math.abs(y - py), 1);\r\n\r\n        if (dx !== 0) {\r\n            if (grid.isWalkableAt(x, y - 1)) {\r\n                neighbors.push([x, y - 1]);\r\n            }\r\n            if (grid.isWalkableAt(x, y + 1)) {\r\n                neighbors.push([x, y + 1]);\r\n            }\r\n            if (grid.isWalkableAt(x + dx, y)) {\r\n                neighbors.push([x + dx, y]);\r\n            }\r\n        }\r\n        else if (dy !== 0) {\r\n            if (grid.isWalkableAt(x - 1, y)) {\r\n                neighbors.push([x - 1, y]);\r\n            }\r\n            if (grid.isWalkableAt(x + 1, y)) {\r\n                neighbors.push([x + 1, y]);\r\n            }\r\n            if (grid.isWalkableAt(x, y + dy)) {\r\n                neighbors.push([x, y + dy]);\r\n            }\r\n        }\r\n    }\r\n    // return all neighbors\r\n    else {\r\n        neighborNodes = grid.getNeighbors(node, DiagonalMovement.Never);\r\n        for (i = 0, l = neighborNodes.length; i < l; ++i) {\r\n            neighborNode = neighborNodes[i];\r\n            neighbors.push([neighborNode.x, neighborNode.y]);\r\n        }\r\n    }\r\n\r\n    return neighbors;\r\n};\r\n\r\nmodule.exports = JPFNeverMoveDiagonally;\r\n", "/**\r\n * @author imor / https://github.com/imor\r\n */\r\nvar JumpPointFinderBase = require('./JumpPointFinderBase');\r\nvar DiagonalMovement = require('../core/DiagonalMovement');\r\n\r\n/**\r\n * Path finder using the Jump Point Search algorithm which always moves\r\n * diagonally irrespective of the number of obstacles.\r\n */\r\nfunction JPFAlwaysMoveDiagonally(opt) {\r\n    JumpPointFinderBase.call(this, opt);\r\n}\r\n\r\nJPFAlwaysMoveDiagonally.prototype = new JumpPointFinderBase();\r\nJPFAlwaysMoveDiagonally.prototype.constructor = JPFAlwaysMoveDiagonally;\r\n\r\n/**\r\n * Search recursively in the direction (parent -> child), stopping only when a\r\n * jump point is found.\r\n * @protected\r\n * @return {Array<Array<number>>} The x, y coordinate of the jump point\r\n *     found, or null if not found\r\n */\r\nJPFAlwaysMoveDiagonally.prototype._jump = function(x, y, px, py) {\r\n    var grid = this.grid,\r\n        dx = x - px, dy = y - py;\r\n\r\n    if (!grid.isWalkableAt(x, y)) {\r\n        return null;\r\n    }\r\n\r\n    if(this.trackJumpRecursion === true) {\r\n        grid.getNodeAt(x, y).tested = true;\r\n    }\r\n\r\n    if (grid.getNodeAt(x, y) === this.endNode) {\r\n        return [x, y];\r\n    }\r\n\r\n    // check for forced neighbors\r\n    // along the diagonal\r\n    if (dx !== 0 && dy !== 0) {\r\n        if ((grid.isWalkableAt(x - dx, y + dy) && !grid.isWalkableAt(x - dx, y)) ||\r\n            (grid.isWalkableAt(x + dx, y - dy) && !grid.isWalkableAt(x, y - dy))) {\r\n            return [x, y];\r\n        }\r\n        // when moving diagonally, must check for vertical/horizontal jump points\r\n        if (this._jump(x + dx, y, x, y) || this._jump(x, y + dy, x, y)) {\r\n            return [x, y];\r\n        }\r\n    }\r\n    // horizontally/vertically\r\n    else {\r\n        if( dx !== 0 ) { // moving along x\r\n            if((grid.isWalkableAt(x + dx, y + 1) && !grid.isWalkableAt(x, y + 1)) ||\r\n               (grid.isWalkableAt(x + dx, y - 1) && !grid.isWalkableAt(x, y - 1))) {\r\n                return [x, y];\r\n            }\r\n        }\r\n        else {\r\n            if((grid.isWalkableAt(x + 1, y + dy) && !grid.isWalkableAt(x + 1, y)) ||\r\n               (grid.isWalkableAt(x - 1, y + dy) && !grid.isWalkableAt(x - 1, y))) {\r\n                return [x, y];\r\n            }\r\n        }\r\n    }\r\n\r\n    return this._jump(x + dx, y + dy, x, y);\r\n};\r\n\r\n/**\r\n * Find the neighbors for the given node. If the node has a parent,\r\n * prune the neighbors based on the jump point search algorithm, otherwise\r\n * return all available neighbors.\r\n * @return {Array<Array<number>>} The neighbors found.\r\n */\r\nJPFAlwaysMoveDiagonally.prototype._findNeighbors = function(node) {\r\n    var parent = node.parent,\r\n        x = node.x, y = node.y,\r\n        grid = this.grid,\r\n        px, py, nx, ny, dx, dy,\r\n        neighbors = [], neighborNodes, neighborNode, i, l;\r\n\r\n    // directed pruning: can ignore most neighbors, unless forced.\r\n    if (parent) {\r\n        px = parent.x;\r\n        py = parent.y;\r\n        // get the normalized direction of travel\r\n        dx = (x - px) / Math.max(Math.abs(x - px), 1);\r\n        dy = (y - py) / Math.max(Math.abs(y - py), 1);\r\n\r\n        // search diagonally\r\n        if (dx !== 0 && dy !== 0) {\r\n            if (grid.isWalkableAt(x, y + dy)) {\r\n                neighbors.push([x, y + dy]);\r\n            }\r\n            if (grid.isWalkableAt(x + dx, y)) {\r\n                neighbors.push([x + dx, y]);\r\n            }\r\n            if (grid.isWalkableAt(x + dx, y + dy)) {\r\n                neighbors.push([x + dx, y + dy]);\r\n            }\r\n            if (!grid.isWalkableAt(x - dx, y)) {\r\n                neighbors.push([x - dx, y + dy]);\r\n            }\r\n            if (!grid.isWalkableAt(x, y - dy)) {\r\n                neighbors.push([x + dx, y - dy]);\r\n            }\r\n        }\r\n        // search horizontally/vertically\r\n        else {\r\n            if(dx === 0) {\r\n                if (grid.isWalkableAt(x, y + dy)) {\r\n                    neighbors.push([x, y + dy]);\r\n                }\r\n                if (!grid.isWalkableAt(x + 1, y)) {\r\n                    neighbors.push([x + 1, y + dy]);\r\n                }\r\n                if (!grid.isWalkableAt(x - 1, y)) {\r\n                    neighbors.push([x - 1, y + dy]);\r\n                }\r\n            }\r\n            else {\r\n                if (grid.isWalkableAt(x + dx, y)) {\r\n                    neighbors.push([x + dx, y]);\r\n                }\r\n                if (!grid.isWalkableAt(x, y + 1)) {\r\n                    neighbors.push([x + dx, y + 1]);\r\n                }\r\n                if (!grid.isWalkableAt(x, y - 1)) {\r\n                    neighbors.push([x + dx, y - 1]);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    // return all neighbors\r\n    else {\r\n        neighborNodes = grid.getNeighbors(node, DiagonalMovement.Always);\r\n        for (i = 0, l = neighborNodes.length; i < l; ++i) {\r\n            neighborNode = neighborNodes[i];\r\n            neighbors.push([neighborNode.x, neighborNode.y]);\r\n        }\r\n    }\r\n\r\n    return neighbors;\r\n};\r\n\r\nmodule.exports = JPFAlwaysMoveDiagonally;\r\n", "/**\r\n * @author imor / https://github.com/imor\r\n */\r\nvar JumpPointFinderBase = require('./JumpPointFinderBase');\r\nvar DiagonalMovement = require('../core/DiagonalMovement');\r\n\r\n/**\r\n * Path finder using the Jump Point Search algorithm which moves\r\n * diagonally only when there are no obstacles.\r\n */\r\nfunction JPFMoveDiagonallyIfNoObstacles(opt) {\r\n    JumpPointFinderBase.call(this, opt);\r\n}\r\n\r\nJPFMoveDiagonallyIfNoObstacles.prototype = new JumpPointFinderBase();\r\nJPFMoveDiagonallyIfNoObstacles.prototype.constructor = JPFMoveDiagonallyIfNoObstacles;\r\n\r\n/**\r\n * Search recursively in the direction (parent -> child), stopping only when a\r\n * jump point is found.\r\n * @protected\r\n * @return {Array<Array<number>>} The x, y coordinate of the jump point\r\n *     found, or null if not found\r\n */\r\nJPFMoveDiagonallyIfNoObstacles.prototype._jump = function(x, y, px, py) {\r\n    var grid = this.grid,\r\n        dx = x - px, dy = y - py;\r\n\r\n    if (!grid.isWalkableAt(x, y)) {\r\n        return null;\r\n    }\r\n\r\n    if(this.trackJumpRecursion === true) {\r\n        grid.getNodeAt(x, y).tested = true;\r\n    }\r\n\r\n    if (grid.getNodeAt(x, y) === this.endNode) {\r\n        return [x, y];\r\n    }\r\n\r\n    // check for forced neighbors\r\n    // along the diagonal\r\n    if (dx !== 0 && dy !== 0) {\r\n        // if ((grid.isWalkableAt(x - dx, y + dy) && !grid.isWalkableAt(x - dx, y)) ||\r\n            // (grid.isWalkableAt(x + dx, y - dy) && !grid.isWalkableAt(x, y - dy))) {\r\n            // return [x, y];\r\n        // }\r\n        // when moving diagonally, must check for vertical/horizontal jump points\r\n        if (this._jump(x + dx, y, x, y) || this._jump(x, y + dy, x, y)) {\r\n            return [x, y];\r\n        }\r\n    }\r\n    // horizontally/vertically\r\n    else {\r\n        if (dx !== 0) {\r\n            if ((grid.isWalkableAt(x, y - 1) && !grid.isWalkableAt(x - dx, y - 1)) ||\r\n                (grid.isWalkableAt(x, y + 1) && !grid.isWalkableAt(x - dx, y + 1))) {\r\n                return [x, y];\r\n            }\r\n        }\r\n        else if (dy !== 0) {\r\n            if ((grid.isWalkableAt(x - 1, y) && !grid.isWalkableAt(x - 1, y - dy)) ||\r\n                (grid.isWalkableAt(x + 1, y) && !grid.isWalkableAt(x + 1, y - dy))) {\r\n                return [x, y];\r\n            }\r\n            // When moving vertically, must check for horizontal jump points\r\n            // if (this._jump(x + 1, y, x, y) || this._jump(x - 1, y, x, y)) {\r\n                // return [x, y];\r\n            // }\r\n        }\r\n    }\r\n\r\n    // moving diagonally, must make sure one of the vertical/horizontal\r\n    // neighbors is open to allow the path\r\n    if (grid.isWalkableAt(x + dx, y) && grid.isWalkableAt(x, y + dy)) {\r\n        return this._jump(x + dx, y + dy, x, y);\r\n    } else {\r\n        return null;\r\n    }\r\n};\r\n\r\n/**\r\n * Find the neighbors for the given node. If the node has a parent,\r\n * prune the neighbors based on the jump point search algorithm, otherwise\r\n * return all available neighbors.\r\n * @return {Array<Array<number>>} The neighbors found.\r\n */\r\nJPFMoveDiagonallyIfNoObstacles.prototype._findNeighbors = function(node) {\r\n    var parent = node.parent,\r\n        x = node.x, y = node.y,\r\n        grid = this.grid,\r\n        px, py, nx, ny, dx, dy,\r\n        neighbors = [], neighborNodes, neighborNode, i, l;\r\n\r\n    // directed pruning: can ignore most neighbors, unless forced.\r\n    if (parent) {\r\n        px = parent.x;\r\n        py = parent.y;\r\n        // get the normalized direction of travel\r\n        dx = (x - px) / Math.max(Math.abs(x - px), 1);\r\n        dy = (y - py) / Math.max(Math.abs(y - py), 1);\r\n\r\n        // search diagonally\r\n        if (dx !== 0 && dy !== 0) {\r\n            if (grid.isWalkableAt(x, y + dy)) {\r\n                neighbors.push([x, y + dy]);\r\n            }\r\n            if (grid.isWalkableAt(x + dx, y)) {\r\n                neighbors.push([x + dx, y]);\r\n            }\r\n            if (grid.isWalkableAt(x, y + dy) && grid.isWalkableAt(x + dx, y)) {\r\n                neighbors.push([x + dx, y + dy]);\r\n            }\r\n        }\r\n        // search horizontally/vertically\r\n        else {\r\n            var isNextWalkable;\r\n            if (dx !== 0) {\r\n                isNextWalkable = grid.isWalkableAt(x + dx, y);\r\n                var isTopWalkable = grid.isWalkableAt(x, y + 1);\r\n                var isBottomWalkable = grid.isWalkableAt(x, y - 1);\r\n\r\n                if (isNextWalkable) {\r\n                    neighbors.push([x + dx, y]);\r\n                    if (isTopWalkable) {\r\n                        neighbors.push([x + dx, y + 1]);\r\n                    }\r\n                    if (isBottomWalkable) {\r\n                        neighbors.push([x + dx, y - 1]);\r\n                    }\r\n                }\r\n                if (isTopWalkable) {\r\n                    neighbors.push([x, y + 1]);\r\n                }\r\n                if (isBottomWalkable) {\r\n                    neighbors.push([x, y - 1]);\r\n                }\r\n            }\r\n            else if (dy !== 0) {\r\n                isNextWalkable = grid.isWalkableAt(x, y + dy);\r\n                var isRightWalkable = grid.isWalkableAt(x + 1, y);\r\n                var isLeftWalkable = grid.isWalkableAt(x - 1, y);\r\n\r\n                if (isNextWalkable) {\r\n                    neighbors.push([x, y + dy]);\r\n                    if (isRightWalkable) {\r\n                        neighbors.push([x + 1, y + dy]);\r\n                    }\r\n                    if (isLeftWalkable) {\r\n                        neighbors.push([x - 1, y + dy]);\r\n                    }\r\n                }\r\n                if (isRightWalkable) {\r\n                    neighbors.push([x + 1, y]);\r\n                }\r\n                if (isLeftWalkable) {\r\n                    neighbors.push([x - 1, y]);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    // return all neighbors\r\n    else {\r\n        neighborNodes = grid.getNeighbors(node, DiagonalMovement.OnlyWhenNoObstacles);\r\n        for (i = 0, l = neighborNodes.length; i < l; ++i) {\r\n            neighborNode = neighborNodes[i];\r\n            neighbors.push([neighborNode.x, neighborNode.y]);\r\n        }\r\n    }\r\n\r\n    return neighbors;\r\n};\r\n\r\nmodule.exports = JPFMoveDiagonallyIfNoObstacles;\r\n", "/**\r\n * @author imor / https://github.com/imor\r\n */\r\nvar JumpPointFinderBase = require('./JumpPointFinderBase');\r\nvar DiagonalMovement = require('../core/DiagonalMovement');\r\n\r\n/**\r\n * Path finder using the Jump Point Search algorithm which moves\r\n * diagonally only when there is at most one obstacle.\r\n */\r\nfunction JPFMoveDiagonallyIfAtMostOneObstacle(opt) {\r\n    JumpPointFinderBase.call(this, opt);\r\n}\r\n\r\nJPFMoveDiagonallyIfAtMostOneObstacle.prototype = new JumpPointFinderBase();\r\nJPFMoveDiagonallyIfAtMostOneObstacle.prototype.constructor = JPFMoveDiagonallyIfAtMostOneObstacle;\r\n\r\n/**\r\n * Search recursively in the direction (parent -> child), stopping only when a\r\n * jump point is found.\r\n * @protected\r\n * @return {Array<Array<number>>} The x, y coordinate of the jump point\r\n *     found, or null if not found\r\n */\r\nJPFMoveDiagonallyIfAtMostOneObstacle.prototype._jump = function(x, y, px, py) {\r\n    var grid = this.grid,\r\n        dx = x - px, dy = y - py;\r\n\r\n    if (!grid.isWalkableAt(x, y)) {\r\n        return null;\r\n    }\r\n\r\n    if(this.trackJumpRecursion === true) {\r\n        grid.getNodeAt(x, y).tested = true;\r\n    }\r\n\r\n    if (grid.getNodeAt(x, y) === this.endNode) {\r\n        return [x, y];\r\n    }\r\n\r\n    // check for forced neighbors\r\n    // along the diagonal\r\n    if (dx !== 0 && dy !== 0) {\r\n        if ((grid.isWalkableAt(x - dx, y + dy) && !grid.isWalkableAt(x - dx, y)) ||\r\n            (grid.isWalkableAt(x + dx, y - dy) && !grid.isWalkableAt(x, y - dy))) {\r\n            return [x, y];\r\n        }\r\n        // when moving diagonally, must check for vertical/horizontal jump points\r\n        if (this._jump(x + dx, y, x, y) || this._jump(x, y + dy, x, y)) {\r\n            return [x, y];\r\n        }\r\n    }\r\n    // horizontally/vertically\r\n    else {\r\n        if( dx !== 0 ) { // moving along x\r\n            if((grid.isWalkableAt(x + dx, y + 1) && !grid.isWalkableAt(x, y + 1)) ||\r\n               (grid.isWalkableAt(x + dx, y - 1) && !grid.isWalkableAt(x, y - 1))) {\r\n                return [x, y];\r\n            }\r\n        }\r\n        else {\r\n            if((grid.isWalkableAt(x + 1, y + dy) && !grid.isWalkableAt(x + 1, y)) ||\r\n               (grid.isWalkableAt(x - 1, y + dy) && !grid.isWalkableAt(x - 1, y))) {\r\n                return [x, y];\r\n            }\r\n        }\r\n    }\r\n\r\n    // moving diagonally, must make sure one of the vertical/horizontal\r\n    // neighbors is open to allow the path\r\n    if (grid.isWalkableAt(x + dx, y) || grid.isWalkableAt(x, y + dy)) {\r\n        return this._jump(x + dx, y + dy, x, y);\r\n    } else {\r\n        return null;\r\n    }\r\n};\r\n\r\n/**\r\n * Find the neighbors for the given node. If the node has a parent,\r\n * prune the neighbors based on the jump point search algorithm, otherwise\r\n * return all available neighbors.\r\n * @return {Array<Array<number>>} The neighbors found.\r\n */\r\nJPFMoveDiagonallyIfAtMostOneObstacle.prototype._findNeighbors = function(node) {\r\n    var parent = node.parent,\r\n        x = node.x, y = node.y,\r\n        grid = this.grid,\r\n        px, py, nx, ny, dx, dy,\r\n        neighbors = [], neighborNodes, neighborNode, i, l;\r\n\r\n    // directed pruning: can ignore most neighbors, unless forced.\r\n    if (parent) {\r\n        px = parent.x;\r\n        py = parent.y;\r\n        // get the normalized direction of travel\r\n        dx = (x - px) / Math.max(Math.abs(x - px), 1);\r\n        dy = (y - py) / Math.max(Math.abs(y - py), 1);\r\n\r\n        // search diagonally\r\n        if (dx !== 0 && dy !== 0) {\r\n            if (grid.isWalkableAt(x, y + dy)) {\r\n                neighbors.push([x, y + dy]);\r\n            }\r\n            if (grid.isWalkableAt(x + dx, y)) {\r\n                neighbors.push([x + dx, y]);\r\n            }\r\n            if (grid.isWalkableAt(x, y + dy) || grid.isWalkableAt(x + dx, y)) {\r\n                neighbors.push([x + dx, y + dy]);\r\n            }\r\n            if (!grid.isWalkableAt(x - dx, y) && grid.isWalkableAt(x, y + dy)) {\r\n                neighbors.push([x - dx, y + dy]);\r\n            }\r\n            if (!grid.isWalkableAt(x, y - dy) && grid.isWalkableAt(x + dx, y)) {\r\n                neighbors.push([x + dx, y - dy]);\r\n            }\r\n        }\r\n        // search horizontally/vertically\r\n        else {\r\n            if(dx === 0) {\r\n                if (grid.isWalkableAt(x, y + dy)) {\r\n                    neighbors.push([x, y + dy]);\r\n                    if (!grid.isWalkableAt(x + 1, y)) {\r\n                        neighbors.push([x + 1, y + dy]);\r\n                    }\r\n                    if (!grid.isWalkableAt(x - 1, y)) {\r\n                        neighbors.push([x - 1, y + dy]);\r\n                    }\r\n                }\r\n            }\r\n            else {\r\n                if (grid.isWalkableAt(x + dx, y)) {\r\n                    neighbors.push([x + dx, y]);\r\n                    if (!grid.isWalkableAt(x, y + 1)) {\r\n                        neighbors.push([x + dx, y + 1]);\r\n                    }\r\n                    if (!grid.isWalkableAt(x, y - 1)) {\r\n                        neighbors.push([x + dx, y - 1]);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    // return all neighbors\r\n    else {\r\n        neighborNodes = grid.getNeighbors(node, DiagonalMovement.IfAtMostOneObstacle);\r\n        for (i = 0, l = neighborNodes.length; i < l; ++i) {\r\n            neighborNode = neighborNodes[i];\r\n            neighbors.push([neighborNode.x, neighborNode.y]);\r\n        }\r\n    }\r\n\r\n    return neighbors;\r\n};\r\n\r\nmodule.exports = JPFMoveDiagonallyIfAtMostOneObstacle;\r\n", "/**\r\n * @author aniero / https://github.com/aniero\r\n */\r\nvar DiagonalMovement = require('../core/DiagonalMovement');\r\nvar JPFNeverMoveDiagonally = require('./JPFNeverMoveDiagonally');\r\nvar JPFAlwaysMoveDiagonally = require('./JPFAlwaysMoveDiagonally');\r\nvar JPFMoveDiagonallyIfNoObstacles = require('./JPFMoveDiagonallyIfNoObstacles');\r\nvar JPFMoveDiagonallyIfAtMostOneObstacle = require('./JPFMoveDiagonallyIfAtMostOneObstacle');\r\n\r\n/**\r\n * Path finder using the Jump Point Search algorithm\r\n * @param {Object} opt\r\n * @param {function} opt.heuristic Heuristic function to estimate the distance\r\n *     (defaults to manhattan).\r\n * @param {DiagonalMovement} opt.diagonalMovement Condition under which diagonal\r\n *      movement will be allowed.\r\n */\r\nfunction JumpPointFinder(opt) {\r\n    opt = opt || {};\r\n    if (opt.diagonalMovement === DiagonalMovement.Never) {\r\n        return new JPFNeverMoveDiagonally(opt);\r\n    } else if (opt.diagonalMovement === DiagonalMovement.Always) {\r\n        return new JPFAlwaysMoveDiagonally(opt);\r\n    } else if (opt.diagonalMovement === DiagonalMovement.OnlyWhenNoObstacles) {\r\n        return new JPFMoveDiagonallyIfNoObstacles(opt);\r\n    } else {\r\n        return new JPFMoveDiagonallyIfAtMostOneObstacle(opt);\r\n    }\r\n}\r\n\r\nmodule.exports = JumpPointFinder;\r\n", "module.exports = {\r\n    'Heap'                      : require('heap'),\r\n    'Node'                      : require('./core/Node'),\r\n    'Grid'                      : require('./core/Grid'),\r\n    'Util'                      : require('./core/Util'),\r\n    'DiagonalMovement'          : require('./core/DiagonalMovement'),\r\n    'Heuristic'                 : require('./core/Heuristic'),\r\n    'AStarFinder'               : require('./finders/AStarFinder'),\r\n    'BestFirstFinder'           : require('./finders/BestFirstFinder'),\r\n    'BreadthFirstFinder'        : require('./finders/BreadthFirstFinder'),\r\n    'DijkstraFinder'            : require('./finders/DijkstraFinder'),\r\n    'BiAStarFinder'             : require('./finders/BiAStarFinder'),\r\n    'BiBestFirstFinder'         : require('./finders/BiBestFirstFinder'),\r\n    'BiBreadthFirstFinder'      : require('./finders/BiBreadthFirstFinder'),\r\n    'BiDijkstraFinder'          : require('./finders/BiDijkstraFinder'),\r\n    'IDAStarFinder'             : require('./finders/IDAStarFinder'),\r\n    'JumpPointFinder'           : require('./finders/JumpPointFinder'),\r\n};\r\n", "module.exports = require('./src/PathFinding');\r\n", "import { useReducer, useRef, useDebugValue, useEffect, useLayoutEffect } from 'react';\n\nfunction createStore(createState) {\n  let state;\n  const listeners = /* @__PURE__ */ new Set();\n  const setState = (partial, replace) => {\n    const nextState = typeof partial === \"function\" ? partial(state) : partial;\n    if (nextState !== state) {\n      const previousState = state;\n      state = replace ? nextState : Object.assign({}, state, nextState);\n      listeners.forEach((listener) => listener(state, previousState));\n    }\n  };\n  const getState = () => state;\n  const subscribeWithSelector = (listener, selector = getState, equalityFn = Object.is) => {\n    console.warn(\"[DEPRECATED] Please use `subscribeWithSelector` middleware\");\n    let currentSlice = selector(state);\n    function listenerToAdd() {\n      const nextSlice = selector(state);\n      if (!equalityFn(currentSlice, nextSlice)) {\n        const previousSlice = currentSlice;\n        listener(currentSlice = nextSlice, previousSlice);\n      }\n    }\n    listeners.add(listenerToAdd);\n    return () => listeners.delete(listenerToAdd);\n  };\n  const subscribe = (listener, selector, equalityFn) => {\n    if (selector || equalityFn) {\n      return subscribeWithSelector(listener, selector, equalityFn);\n    }\n    listeners.add(listener);\n    return () => listeners.delete(listener);\n  };\n  const destroy = () => listeners.clear();\n  const api = { setState, getState, subscribe, destroy };\n  state = createState(setState, getState, api);\n  return api;\n}\n\nconst isSSR = typeof window === \"undefined\" || !window.navigator || /ServerSideRendering|^Deno\\//.test(window.navigator.userAgent);\nconst useIsomorphicLayoutEffect = isSSR ? useEffect : useLayoutEffect;\nfunction create(createState) {\n  const api = typeof createState === \"function\" ? createStore(createState) : createState;\n  const useStore = (selector = api.getState, equalityFn = Object.is) => {\n    const [, forceUpdate] = useReducer((c) => c + 1, 0);\n    const state = api.getState();\n    const stateRef = useRef(state);\n    const selectorRef = useRef(selector);\n    const equalityFnRef = useRef(equalityFn);\n    const erroredRef = useRef(false);\n    const currentSliceRef = useRef();\n    if (currentSliceRef.current === void 0) {\n      currentSliceRef.current = selector(state);\n    }\n    let newStateSlice;\n    let hasNewStateSlice = false;\n    if (stateRef.current !== state || selectorRef.current !== selector || equalityFnRef.current !== equalityFn || erroredRef.current) {\n      newStateSlice = selector(state);\n      hasNewStateSlice = !equalityFn(currentSliceRef.current, newStateSlice);\n    }\n    useIsomorphicLayoutEffect(() => {\n      if (hasNewStateSlice) {\n        currentSliceRef.current = newStateSlice;\n      }\n      stateRef.current = state;\n      selectorRef.current = selector;\n      equalityFnRef.current = equalityFn;\n      erroredRef.current = false;\n    });\n    const stateBeforeSubscriptionRef = useRef(state);\n    useIsomorphicLayoutEffect(() => {\n      const listener = () => {\n        try {\n          const nextState = api.getState();\n          const nextStateSlice = selectorRef.current(nextState);\n          if (!equalityFnRef.current(currentSliceRef.current, nextStateSlice)) {\n            stateRef.current = nextState;\n            currentSliceRef.current = nextStateSlice;\n            forceUpdate();\n          }\n        } catch (error) {\n          erroredRef.current = true;\n          forceUpdate();\n        }\n      };\n      const unsubscribe = api.subscribe(listener);\n      if (api.getState() !== stateBeforeSubscriptionRef.current) {\n        listener();\n      }\n      return unsubscribe;\n    }, []);\n    const sliceToReturn = hasNewStateSlice ? newStateSlice : currentSliceRef.current;\n    useDebugValue(sliceToReturn);\n    return sliceToReturn;\n  };\n  Object.assign(useStore, api);\n  useStore[Symbol.iterator] = function() {\n    console.warn(\"[useStore, api] = create() is deprecated and will be removed in v4\");\n    const items = [useStore, api];\n    return {\n      next() {\n        const done = items.length <= 0;\n        return { value: items.shift(), done };\n      }\n    };\n  };\n  return useStore;\n}\n\nexport { create as default };\n", "import { createContext as createContext$1, useRef, createElement, useContext, useMemo } from 'react';\n\nfunction createContext() {\n  const ZustandContext = createContext$1(void 0);\n  const Provider = ({\n    initialStore,\n    createStore,\n    children\n  }) => {\n    const storeRef = useRef();\n    if (!storeRef.current) {\n      if (initialStore) {\n        console.warn(\"Provider initialStore is deprecated and will be removed in the next version.\");\n        if (!createStore) {\n          createStore = () => initialStore;\n        }\n      }\n      storeRef.current = createStore();\n    }\n    return createElement(ZustandContext.Provider, { value: storeRef.current }, children);\n  };\n  const useStore = (selector, equalityFn = Object.is) => {\n    const useProviderStore = useContext(ZustandContext);\n    if (!useProviderStore) {\n      throw new Error(\"Seems like you have not used zustand provider as an ancestor.\");\n    }\n    return useProviderStore(selector, equalityFn);\n  };\n  const useStoreApi = () => {\n    const useProviderStore = useContext(ZustandContext);\n    if (!useProviderStore) {\n      throw new Error(\"Seems like you have not used zustand provider as an ancestor.\");\n    }\n    return useMemo(() => ({\n      getState: useProviderStore.getState,\n      setState: useProviderStore.setState,\n      subscribe: useProviderStore.subscribe,\n      destroy: useProviderStore.destroy\n    }), [useProviderStore]);\n  };\n  return {\n    Provider,\n    useStore,\n    useStoreApi\n  };\n}\n\nexport { createContext as default };\n", "export default function _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}", "export default function _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}", "import arrayLikeToArray from \"./arrayLikeToArray.js\";\nexport default function _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return arrayLikeToArray(o, minLen);\n}", "export default function _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}", "export default function _iterableToArrayLimit(arr, i) {\n  var _i = arr == null ? null : typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"];\n\n  if (_i == null) return;\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n\n  var _s, _e;\n\n  try {\n    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n\n  return _arr;\n}", "export default function _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}", "import arrayWithHoles from \"./arrayWithHoles.js\";\nimport iterableToArrayLimit from \"./iterableToArrayLimit.js\";\nimport unsupportedIterableToArray from \"./unsupportedIterableToArray.js\";\nimport nonIterableRest from \"./nonIterableRest.js\";\nexport default function _slicedToArray(arr, i) {\n  return arrayWithHoles(arr) || iterableToArrayLimit(arr, i) || unsupportedIterableToArray(arr, i) || nonIterableRest();\n}", "function shallow(objA, objB) {\n  if (Object.is(objA, objB)) {\n    return true;\n  }\n  if (typeof objA !== \"object\" || objA === null || typeof objB !== \"object\" || objB === null) {\n    return false;\n  }\n  const keysA = Object.keys(objA);\n  if (keysA.length !== Object.keys(objB).length) {\n    return false;\n  }\n  for (let i = 0; i < keysA.length; i++) {\n    if (!Object.prototype.hasOwnProperty.call(objB, keysA[i]) || !Object.is(objA[keysA[i]], objB[keysA[i]])) {\n      return false;\n    }\n  }\n  return true;\n}\n\nexport { shallow as default };\n", "import arrayLikeToArray from \"./arrayLikeToArray.js\";\nexport default function _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return arrayLikeToArray(arr);\n}", "export default function _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter);\n}", "export default function _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}", "import arrayWithoutHoles from \"./arrayWithoutHoles.js\";\nimport iterableToArray from \"./iterableToArray.js\";\nimport unsupportedIterableToArray from \"./unsupportedIterableToArray.js\";\nimport nonIterableSpread from \"./nonIterableSpread.js\";\nexport default function _toConsumableArray(arr) {\n  return arrayWithoutHoles(arr) || iterableToArray(arr) || unsupportedIterableToArray(arr) || nonIterableSpread();\n}", "export default function _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n\n  return target;\n}", "import objectWithoutPropertiesLoose from \"./objectWithoutPropertiesLoose.js\";\nexport default function _objectWithoutProperties(source, excluded) {\n  if (source == null) return {};\n  var target = objectWithoutPropertiesLoose(source, excluded);\n  var key, i;\n\n  if (Object.getOwnPropertySymbols) {\n    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n\n    for (i = 0; i < sourceSymbolKeys.length; i++) {\n      key = sourceSymbolKeys[i];\n      if (excluded.indexOf(key) >= 0) continue;\n      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n      target[key] = source[key];\n    }\n  }\n\n  return target;\n}", "import React, { memo } from 'react';\nimport cc from 'classcat';\nimport shallow from 'zustand/shallow';\nimport { b as useStore, I as getBoundsofRects, o as getRectOfNodes } from './index-a12c80bd.js';\nimport 'zustand';\nimport 'zustand/context';\nimport 'd3-zoom';\n\nvar MiniMapNode = function MiniMapNode(_ref) {\n  var x = _ref.x,\n      y = _ref.y,\n      width = _ref.width,\n      height = _ref.height,\n      style = _ref.style,\n      color = _ref.color,\n      strokeColor = _ref.strokeColor,\n      strokeWidth = _ref.strokeWidth,\n      className = _ref.className,\n      borderRadius = _ref.borderRadius,\n      shapeRendering = _ref.shapeRendering;\n\n  var _ref2 = style || {},\n      background = _ref2.background,\n      backgroundColor = _ref2.backgroundColor;\n\n  var fill = color || background || backgroundColor;\n  return /*#__PURE__*/React.createElement(\"rect\", {\n    className: cc(['react-flow__minimap-node', className]),\n    x: x,\n    y: y,\n    rx: borderRadius,\n    ry: borderRadius,\n    width: width,\n    height: height,\n    fill: fill,\n    stroke: strokeColor,\n    strokeWidth: strokeWidth,\n    shapeRendering: shapeRendering\n  });\n};\n\nMiniMapNode.displayName = 'MiniMapNode';\nvar MiniMapNode$1 = /*#__PURE__*/memo(MiniMapNode);\n\nvar defaultWidth = 200;\nvar defaultHeight = 150;\n\nvar selector = function selector(s) {\n  return {\n    viewBBox: {\n      x: -s.transform[0] / s.transform[2],\n      y: -s.transform[1] / s.transform[2],\n      width: s.width / s.transform[2],\n      height: s.height / s.transform[2]\n    },\n    nodes: Array.from(s.nodeInternals.values())\n  };\n};\n\nvar getAttrFunction = function getAttrFunction(func) {\n  return func instanceof Function ? func : function () {\n    return func;\n  };\n};\n\nvar MiniMap = function MiniMap(_ref) {\n  var _style$width, _style$height;\n\n  var style = _ref.style,\n      className = _ref.className,\n      _ref$nodeStrokeColor = _ref.nodeStrokeColor,\n      nodeStrokeColor = _ref$nodeStrokeColor === void 0 ? '#555' : _ref$nodeStrokeColor,\n      _ref$nodeColor = _ref.nodeColor,\n      nodeColor = _ref$nodeColor === void 0 ? '#fff' : _ref$nodeColor,\n      _ref$nodeClassName = _ref.nodeClassName,\n      nodeClassName = _ref$nodeClassName === void 0 ? '' : _ref$nodeClassName,\n      _ref$nodeBorderRadius = _ref.nodeBorderRadius,\n      nodeBorderRadius = _ref$nodeBorderRadius === void 0 ? 5 : _ref$nodeBorderRadius,\n      _ref$nodeStrokeWidth = _ref.nodeStrokeWidth,\n      nodeStrokeWidth = _ref$nodeStrokeWidth === void 0 ? 2 : _ref$nodeStrokeWidth,\n      _ref$maskColor = _ref.maskColor,\n      maskColor = _ref$maskColor === void 0 ? 'rgb(240, 242, 243, 0.7)' : _ref$maskColor;\n\n  var _useStore = useStore(selector, shallow),\n      viewBBox = _useStore.viewBBox,\n      nodes = _useStore.nodes;\n\n  var elementWidth = (_style$width = style === null || style === void 0 ? void 0 : style.width) !== null && _style$width !== void 0 ? _style$width : defaultWidth;\n  var elementHeight = (_style$height = style === null || style === void 0 ? void 0 : style.height) !== null && _style$height !== void 0 ? _style$height : defaultHeight;\n  var nodeColorFunc = getAttrFunction(nodeColor);\n  var nodeStrokeColorFunc = getAttrFunction(nodeStrokeColor);\n  var nodeClassNameFunc = getAttrFunction(nodeClassName);\n  var boundingRect = nodes.length > 0 ? getBoundsofRects(getRectOfNodes(nodes), viewBBox) : viewBBox;\n  var scaledWidth = boundingRect.width / elementWidth;\n  var scaledHeight = boundingRect.height / elementHeight;\n  var viewScale = Math.max(scaledWidth, scaledHeight);\n  var viewWidth = viewScale * elementWidth;\n  var viewHeight = viewScale * elementHeight;\n  var offset = 5 * viewScale;\n  var x = boundingRect.x - (viewWidth - boundingRect.width) / 2 - offset;\n  var y = boundingRect.y - (viewHeight - boundingRect.height) / 2 - offset;\n  var width = viewWidth + offset * 2;\n  var height = viewHeight + offset * 2;\n  var shapeRendering = typeof window === 'undefined' || !!window.chrome ? 'crispEdges' : 'geometricPrecision';\n  return /*#__PURE__*/React.createElement(\"svg\", {\n    width: elementWidth,\n    height: elementHeight,\n    viewBox: \"\".concat(x, \" \").concat(y, \" \").concat(width, \" \").concat(height),\n    style: style,\n    className: cc(['react-flow__minimap', className])\n  }, nodes.filter(function (node) {\n    return !node.hidden && node.width && node.height;\n  }).map(function (node) {\n    var _node$positionAbsolut, _node$positionAbsolut2, _node$positionAbsolut3, _node$positionAbsolut4;\n\n    return /*#__PURE__*/React.createElement(MiniMapNode$1, {\n      key: node.id,\n      x: (_node$positionAbsolut = (_node$positionAbsolut2 = node.positionAbsolute) === null || _node$positionAbsolut2 === void 0 ? void 0 : _node$positionAbsolut2.x) !== null && _node$positionAbsolut !== void 0 ? _node$positionAbsolut : 0,\n      y: (_node$positionAbsolut3 = (_node$positionAbsolut4 = node.positionAbsolute) === null || _node$positionAbsolut4 === void 0 ? void 0 : _node$positionAbsolut4.y) !== null && _node$positionAbsolut3 !== void 0 ? _node$positionAbsolut3 : 0,\n      width: node.width,\n      height: node.height,\n      style: node.style,\n      className: nodeClassNameFunc(node),\n      color: nodeColorFunc(node),\n      borderRadius: nodeBorderRadius,\n      strokeColor: nodeStrokeColorFunc(node),\n      strokeWidth: nodeStrokeWidth,\n      shapeRendering: shapeRendering\n    });\n  }), /*#__PURE__*/React.createElement(\"path\", {\n    className: \"react-flow__minimap-mask\",\n    d: \"M\".concat(x - offset, \",\").concat(y - offset, \"h\").concat(width + offset * 2, \"v\").concat(height + offset * 2, \"h\").concat(-width - offset * 2, \"z\\n        M\").concat(viewBBox.x, \",\").concat(viewBBox.y, \"h\").concat(viewBBox.width, \"v\").concat(viewBBox.height, \"h\").concat(-viewBBox.width, \"z\"),\n    fill: maskColor,\n    fillRule: \"evenodd\"\n  }));\n};\n\nMiniMap.displayName = 'MiniMap';\nvar index = /*#__PURE__*/memo(MiniMap);\n\nexport { index as default };\n//# sourceMappingURL=index2.js.map\n", "import { a as _defineProperty, H as BackgroundVariant, _ as _slicedToArray, b as useStore } from './index-a12c80bd.js';\nimport React, { memo, useRef, useState, useEffect } from 'react';\nimport cc from 'classcat';\nimport 'zustand';\nimport 'zustand/context';\nimport 'd3-zoom';\n\nvar createGridLinesPath = function createGridLinesPath(size, strokeWidth, stroke) {\n  return /*#__PURE__*/React.createElement(\"path\", {\n    stroke: stroke,\n    strokeWidth: strokeWidth,\n    d: \"M\".concat(size / 2, \" 0 V\").concat(size, \" M0 \").concat(size / 2, \" H\").concat(size)\n  });\n};\nvar createGridDotsPath = function createGridDotsPath(size, fill) {\n  return /*#__PURE__*/React.createElement(\"circle\", {\n    cx: size,\n    cy: size,\n    r: size,\n    fill: fill\n  });\n};\n\nvar _defaultColors;\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nvar defaultColors = (_defaultColors = {}, _defineProperty(_defaultColors, BackgroundVariant.Dots, '#81818a'), _defineProperty(_defaultColors, BackgroundVariant.Lines, '#eee'), _defaultColors);\n\nvar transformSelector = function transformSelector(s) {\n  return s.transform;\n};\n\nvar Background = function Background(_ref) {\n  var _ref$variant = _ref.variant,\n      variant = _ref$variant === void 0 ? BackgroundVariant.Dots : _ref$variant,\n      _ref$gap = _ref.gap,\n      gap = _ref$gap === void 0 ? 15 : _ref$gap,\n      _ref$size = _ref.size,\n      size = _ref$size === void 0 ? 0.4 : _ref$size,\n      color = _ref.color,\n      style = _ref.style,\n      className = _ref.className;\n  var ref = useRef(null);\n\n  var _useState = useState(null),\n      _useState2 = _slicedToArray(_useState, 2),\n      patternId = _useState2[0],\n      setPatternId = _useState2[1];\n\n  var _useStore = useStore(transformSelector),\n      _useStore2 = _slicedToArray(_useStore, 3),\n      tX = _useStore2[0],\n      tY = _useStore2[1],\n      tScale = _useStore2[2];\n\n  useEffect(function () {\n    // when there are multiple flows on a page we need to make sure that every background gets its own pattern.\n    var bgs = document.querySelectorAll('.react-flow__background');\n    var index = Array.from(bgs).findIndex(function (bg) {\n      return bg === ref.current;\n    });\n    setPatternId(\"pattern-\".concat(index));\n  }, []);\n  var scaledGap = gap * tScale || 1;\n  var xOffset = tX % scaledGap;\n  var yOffset = tY % scaledGap;\n  var isLines = variant === BackgroundVariant.Lines;\n  var bgColor = color ? color : defaultColors[variant];\n  var path = isLines ? createGridLinesPath(scaledGap, size, bgColor) : createGridDotsPath(size * tScale, bgColor);\n  return /*#__PURE__*/React.createElement(\"svg\", {\n    className: cc(['react-flow__background', 'react-flow__container', className]),\n    style: _objectSpread(_objectSpread({}, style), {}, {\n      width: '100%',\n      height: '100%'\n    }),\n    ref: ref\n  }, patternId && /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement(\"pattern\", {\n    id: patternId,\n    x: xOffset,\n    y: yOffset,\n    width: scaledGap,\n    height: scaledGap,\n    patternUnits: \"userSpaceOnUse\"\n  }, path), /*#__PURE__*/React.createElement(\"rect\", {\n    x: \"0\",\n    y: \"0\",\n    width: \"100%\",\n    height: \"100%\",\n    fill: \"url(#\".concat(patternId, \")\")\n  })));\n};\n\nBackground.displayName = 'Background';\nvar index = /*#__PURE__*/memo(Background);\n\nexport { index as default };\n//# sourceMappingURL=index3.js.map\n", "import { useCallback } from 'react';\nimport { u as useStoreApi, b as useStore } from './index-a12c80bd.js';\nimport 'zustand';\nimport 'zustand/context';\nimport 'd3-zoom';\n\nvar selector = function selector(state) {\n  return state.updateNodeDimensions;\n};\n\nfunction useUpdateNodeInternals() {\n  var store = useStoreApi();\n  var updateNodeDimensions = useStore(selector);\n  return useCallback(function (id) {\n    var _store$getState$domNo;\n\n    var nodeElement = (_store$getState$domNo = store.getState().domNode) === null || _store$getState$domNo === void 0 ? void 0 : _store$getState$domNo.querySelector(\".react-flow__node[data-id=\\\"\".concat(id, \"\\\"]\"));\n\n    if (nodeElement) {\n      requestAnimationFrame(function () {\n        return updateNodeDimensions([{\n          id: id,\n          nodeElement: nodeElement,\n          forceUpdate: true\n        }]);\n      });\n    }\n  }, []);\n}\n\nexport { useUpdateNodeInternals as default };\n//# sourceMappingURL=useUpdateNodeInternals.js.map\n", "import { b as useStore } from './index-a12c80bd.js';\nimport 'zustand';\nimport 'zustand/context';\nimport 'd3-zoom';\n\nvar nodesSelector = function nodesSelector(state) {\n  return Array.from(state.nodeInternals.values());\n};\n\nfunction useNodes() {\n  var nodes = useStore(nodesSelector);\n  return nodes;\n}\n\nexport { useNodes as default };\n//# sourceMappingURL=useNodes.js.map\n", "export default function _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) {\n    return typeof obj;\n  } : function (obj) {\n    return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n  }, _typeof(obj);\n}", "import type { Grid } from 'pathfinding'\nimport type { Position, XYPosition } from 'react-flow-renderer'\n\ntype Direction = 'top' | 'bottom' | 'left' | 'right'\n\nexport const getNextPointFromPosition = (\n\tpoint: XYPosition,\n\tposition: Direction\n): XYPosition => {\n\tswitch (position) {\n\t\tcase 'top':\n\t\t\treturn { x: point.x, y: point.y - 1 }\n\t\tcase 'bottom':\n\t\t\treturn { x: point.x, y: point.y + 1 }\n\t\tcase 'left':\n\t\t\treturn { x: point.x - 1, y: point.y }\n\t\tcase 'right':\n\t\t\treturn { x: point.x + 1, y: point.y }\n\t}\n}\n\n/**\n * Guarantee that the path is walkable, even if the point is inside a non\n * walkable area, by adding a walkable path in the direction of the point's\n * Position.\n */\nexport const guaranteeWalkablePath = (\n\tgrid: Grid,\n\tpoint: XYPosition,\n\tposition: Position\n) => {\n\tlet node = grid.getNodeAt(point.x, point.y)\n\twhile (!node.walkable) {\n\t\tgrid.setWalkableAt(node.x, node.y, true)\n\t\tconst next = getNextPointFromPosition(node, position)\n\t\tnode = grid.getNodeAt(next.x, next.y)\n\t}\n}\n", "import type { XYPosition } from 'react-flow-renderer'\n\n/**\n * Each bounding box is a collection of X/Y points in a graph, and we\n * need to convert them to \"occupied\" cells in a 2D grid representation.\n *\n * The top most position of the grid (grid[0][0]) needs to be equivalent\n * to the top most point in the graph (the graph.topLeft point).\n *\n * Since the top most point can have X/Y values different than zero,\n * and each cell in a grid represents a 10x10 pixel area in the grid (or a\n * gridRatio area), there's need to be a conversion between a point in a graph\n * to a point in the grid.\n *\n * We do this conversion by dividing a graph point X/Y values by the grid ratio,\n * and \"shifting\" their values up or down, depending on the values of the top\n * most point in the graph. The top most point in the graph will have the\n * smallest values for X and Y.\n *\n * We avoid setting nodes in the border of the grid (x=0 or y=0), so there's\n * always a \"walkable\" area around the grid.\n */\nexport const graphToGridPoint = (\n\tgraphPoint: XYPosition,\n\tsmallestX: number,\n\tsmallestY: number,\n\tgridRatio: number\n): XYPosition => {\n\tlet x = graphPoint.x / gridRatio\n\tlet y = graphPoint.y / gridRatio\n\n\tlet referenceX = smallestX / gridRatio\n\tlet referenceY = smallestY / gridRatio\n\n\tif (referenceX < 1) {\n\t\twhile (referenceX !== 1) {\n\t\t\treferenceX++\n\t\t\tx++\n\t\t}\n\t} else if (referenceX > 1) {\n\t\twhile (referenceX !== 1) {\n\t\t\treferenceX--\n\t\t\tx--\n\t\t}\n\t} else {\n\t\t// Nothing to do\n\t}\n\n\tif (referenceY < 1) {\n\t\twhile (referenceY !== 1) {\n\t\t\treferenceY++\n\t\t\ty++\n\t\t}\n\t} else if (referenceY > 1) {\n\t\twhile (referenceY !== 1) {\n\t\t\treferenceY--\n\t\t\ty--\n\t\t}\n\t} else {\n\t\t// Nothing to do\n\t}\n\n\treturn { x, y }\n}\n\n/**\n * Converts a grid point back to a graph point, using the reverse logic of\n * graphToGridPoint.\n */\nexport const gridToGraphPoint = (\n\tgridPoint: XYPosition,\n\tsmallestX: number,\n\tsmallestY: number,\n\tgridRatio: number\n): XYPosition => {\n\tlet x = gridPoint.x * gridRatio\n\tlet y = gridPoint.y * gridRatio\n\n\tlet referenceX = smallestX\n\tlet referenceY = smallestY\n\n\tif (referenceX < gridRatio) {\n\t\twhile (referenceX !== gridRatio) {\n\t\t\treferenceX = referenceX + gridRatio\n\t\t\tx = x - gridRatio\n\t\t}\n\t} else if (referenceX > gridRatio) {\n\t\twhile (referenceX !== gridRatio) {\n\t\t\treferenceX = referenceX - gridRatio\n\t\t\tx = x + gridRatio\n\t\t}\n\t} else {\n\t\t// Nothing to do\n\t}\n\n\tif (referenceY < gridRatio) {\n\t\twhile (referenceY !== gridRatio) {\n\t\t\treferenceY = referenceY + gridRatio\n\t\t\ty = y - gridRatio\n\t\t}\n\t} else if (referenceY > gridRatio) {\n\t\twhile (referenceY !== gridRatio) {\n\t\t\treferenceY = referenceY - gridRatio\n\t\t\ty = y + gridRatio\n\t\t}\n\t} else {\n\t\t// Nothing to do\n\t}\n\n\treturn { x, y }\n}\n", "export const round = (x: number, multiple = 10) =>\n\tMath.round(x / multiple) * multiple\n\nexport const roundDown = (x: number, multiple = 10) =>\n\tMath.floor(x / multiple) * multiple\n\nexport const roundUp = (x: number, multiple = 10) =>\n\tMath.ceil(x / multiple) * multiple\n\nexport const toInteger = (value: number, min = 0) => {\n\tlet result = Math.max(Math.round(value), min)\n\tresult = Number.isInteger(result) ? result : min\n\tresult = result >= min ? result : min\n\treturn result\n}\n", "import { Grid } from 'pathfinding'\nimport {\n\tguaranteeWalkablePath,\n\tgetNextPointFromPosition\n} from './guaranteeWalkablePath'\nimport { graphToGridPoint } from './pointConversion'\nimport { round, roundUp } from './utils'\nimport type { NodeBoundingBox, GraphBoundingBox } from './getBoundingBoxes'\nimport type { Position } from 'react-flow-renderer'\n\nexport type PointInfo = {\n\tx: number\n\ty: number\n\tposition: Position\n}\n\nexport const createGrid = (\n\tgraph: GraphBoundingBox,\n\tnodes: NodeBoundingBox[],\n\tsource: PointInfo,\n\ttarget: PointInfo,\n\tgridRatio = 2\n) => {\n\tconst { xMin, yMin, width, height } = graph\n\n\t// Create a grid representation of the graph box, where each cell is\n\t// equivalent to 10x10 pixels (or the grid ratio) on the graph. We'll use\n\t// this simplified grid to do pathfinding.\n\tconst mapColumns = roundUp(width, gridRatio) / gridRatio + 1\n\tconst mapRows = roundUp(height, gridRatio) / gridRatio + 1\n\tconst grid = new Grid(mapColumns, mapRows)\n\n\t// Update the grid representation with the space the nodes take up\n\tnodes.forEach((node) => {\n\t\tconst nodeStart = graphToGridPoint(node.topLeft, xMin, yMin, gridRatio)\n\t\tconst nodeEnd = graphToGridPoint(node.bottomRight, xMin, yMin, gridRatio)\n\n\t\tfor (let x = nodeStart.x; x < nodeEnd.x; x++) {\n\t\t\tfor (let y = nodeStart.y; y < nodeEnd.y; y++) {\n\t\t\t\tgrid.setWalkableAt(x, y, false)\n\t\t\t}\n\t\t}\n\t})\n\n\t// Convert the starting and ending graph points to grid points\n\tconst startGrid = graphToGridPoint(\n\t\t{\n\t\t\tx: round(source.x, gridRatio),\n\t\t\ty: round(source.y, gridRatio)\n\t\t},\n\t\txMin,\n\t\tyMin,\n\t\tgridRatio\n\t)\n\n\tconst endGrid = graphToGridPoint(\n\t\t{\n\t\t\tx: round(target.x, gridRatio),\n\t\t\ty: round(target.y, gridRatio)\n\t\t},\n\t\txMin,\n\t\tyMin,\n\t\tgridRatio\n\t)\n\n\t// Guarantee a walkable path between the start and end points, even if the\n\t// source or target where covered by another node or by padding\n\tconst startingNode = grid.getNodeAt(startGrid.x, startGrid.y)\n\tguaranteeWalkablePath(grid, startingNode, source.position)\n\tconst endingNode = grid.getNodeAt(endGrid.x, endGrid.y)\n\tguaranteeWalkablePath(grid, endingNode, target.position)\n\n\t// Use the next closest points as the start and end points, so\n\t// pathfinding does not start too close to the nodes\n\tconst start = getNextPointFromPosition(startingNode, source.position)\n\tconst end = getNextPointFromPosition(endingNode, target.position)\n\n\treturn { grid, start, end }\n}\n", "import type { XYPosition } from 'react-flow-renderer'\n\n/**\n * Takes source and target {x, y} points, together with an array of number\n * tuples [x, y] representing the points along the path, and returns a string\n * to be used as the SVG path.\n */\nexport type SVGDrawFunction = (\n\tsource: XYPosition,\n\ttarget: XYPosition,\n\tpath: number[][]\n) => string\n\n/**\n * Draws a SVG path from a list of points, using straight lines.\n */\nexport const svgDrawStraightLinePath: SVGDrawFunction = (\n\tsource,\n\ttarget,\n\tpath\n) => {\n\tlet svgPathString = `M ${source.x}, ${source.y} `\n\n\tpath.forEach((point) => {\n\t\tconst [x, y] = point\n\t\tsvgPathString += `L ${x}, ${y} `\n\t})\n\n\tsvgPathString += `L ${target.x}, ${target.y} `\n\n\treturn svgPathString\n}\n\n/**\n * Draws a SVG path from a list of points, using rounded lines.\n */\nexport const svgDrawSmoothLinePath: SVGDrawFunction = (\n\tsource,\n\ttarget,\n\tpath\n) => {\n\tconst points = [[source.x, source.y], ...path, [target.x, target.y]]\n\treturn quadraticBezierCurve(points)\n}\n\nconst quadraticBezierCurve = (points: number[][]) => {\n\tconst X = 0\n\tconst Y = 1\n\tlet point = points[0]\n\n\tconst first = points[0]\n\tlet svgPath = `M${first[X]},${first[Y]}M`\n\n\tfor (let i = 0; i < points.length; i++) {\n\t\tconst next = points[i]\n\t\tconst midPoint = getMidPoint(point[X], point[Y], next[X], next[Y])\n\n\t\tsvgPath += ` ${midPoint[X]},${midPoint[Y]}`\n\t\tsvgPath += `Q${next[X]},${next[Y]}`\n\t\tpoint = next\n\t}\n\n\tconst last = points[points.length - 1]\n\tsvgPath += ` ${last[0]},${last[1]}`\n\n\treturn svgPath\n}\n\nconst getMidPoint = (Ax: number, Ay: number, Bx: number, By: number) => {\n\tconst Zx = (Ax - Bx) / 2 + Bx\n\tconst Zy = (Ay - By) / 2 + By\n\treturn [Zx, Zy]\n}\n", "// FIXME: The \"pathfinding\" module doe not have proper typings.\n/* eslint-disable\n\t@typescript-eslint/no-unsafe-call,\n\t@typescript-eslint/no-unsafe-member-access,\n\t@typescript-eslint/no-unsafe-assignment,\n\t@typescript-eslint/ban-ts-comment,\n*/\nimport {\n\tAStarFinder,\n\tJumpPointFinder,\n\tUtil,\n\tDiagonalMovement\n} from 'pathfinding'\nimport type { Grid } from 'pathfinding'\nimport type { XYPosition } from 'react-flow-renderer'\n\n/**\n * Takes source and target {x, y} points, together with an grid representation\n * of the graph, and returns two arrays of number tuples [x, y]. The first\n * array represents the full path from source to target, and the second array\n * represents a condensed path from source to target.\n */\nexport type PathFindingFunction = (\n\tgrid: Grid,\n\tstart: XYPosition,\n\tend: XYPosition\n) => {\n\tfullPath: number[][]\n\tsmoothedPath: number[][]\n} | null\n\nexport const pathfindingAStarDiagonal: PathFindingFunction = (\n\tgrid,\n\tstart,\n\tend\n) => {\n\ttry {\n\t\tconst finder = new AStarFinder({\n\t\t\tdiagonalMovement: DiagonalMovement.Always\n\t\t})\n\t\tconst fullPath = finder.findPath(start.x, start.y, end.x, end.y, grid)\n\t\tconst smoothedPath = Util.smoothenPath(grid, fullPath)\n\t\tif (fullPath.length === 0 || smoothedPath.length === 0) return null\n\t\treturn { fullPath, smoothedPath }\n\t} catch {\n\t\treturn null\n\t}\n}\n\nexport const pathfindingAStarNoDiagonal: PathFindingFunction = (\n\tgrid,\n\tstart,\n\tend\n) => {\n\ttry {\n\t\tconst finder = new AStarFinder({\n\t\t\tdiagonalMovement: DiagonalMovement.Never\n\t\t})\n\t\tconst fullPath = finder.findPath(start.x, start.y, end.x, end.y, grid)\n\t\tconst smoothedPath = Util.smoothenPath(grid, fullPath)\n\t\tif (fullPath.length === 0 || smoothedPath.length === 0) return null\n\t\treturn { fullPath, smoothedPath }\n\t} catch {\n\t\treturn null\n\t}\n}\n\nexport const pathfindingJumpPointNoDiagonal: PathFindingFunction = (\n\tgrid,\n\tstart,\n\tend\n) => {\n\ttry {\n\t\t// FIXME: The \"pathfinding\" module doe not have proper typings.\n\t\t// @ts-ignore\n\t\tconst finder = new JumpPointFinder({\n\t\t\tdiagonalMovement: DiagonalMovement.Never\n\t\t})\n\t\tconst fullPath = finder.findPath(start.x, start.y, end.x, end.y, grid)\n\t\tconst smoothedPath = fullPath\n\t\tif (fullPath.length === 0 || smoothedPath.length === 0) return null\n\t\treturn { fullPath, smoothedPath }\n\t} catch {\n\t\treturn null\n\t}\n}\n", "import { roundUp, roundDown } from './utils'\nimport type { Node, XYPosition } from 'react-flow-renderer'\n\nexport type NodeBoundingBox = {\n\tid: string\n\twidth: number\n\theight: number\n\ttopLeft: XYPosition\n\tbottomLeft: XYPosition\n\ttopRight: XYPosition\n\tbottomRight: XYPosition\n}\n\nexport type GraphBoundingBox = {\n\twidth: number\n\theight: number\n\ttopLeft: XYPosition\n\tbottomLeft: XYPosition\n\ttopRight: XYPosition\n\tbottomRight: XYPosition\n\txMax: number\n\tyMax: number\n\txMin: number\n\tyMin: number\n}\n\n/**\n * Get the bounding box of all nodes and the graph itself, as X/Y coordinates\n * of all corner points.\n *\n * @param nodes The node list\n * @param nodePadding Optional padding to add to the node's and graph bounding boxes\n * @param roundTo Everything will be rounded to this nearest integer\n * @returns Graph and nodes bounding boxes.\n */\nexport const getBoundingBoxes = <NodeDataType = unknown>(\n\tnodes: Node<NodeDataType>[],\n\tnodePadding = 2,\n\troundTo = 2\n) => {\n\tlet xMax = Number.MIN_SAFE_INTEGER\n\tlet yMax = Number.MIN_SAFE_INTEGER\n\tlet xMin = Number.MAX_SAFE_INTEGER\n\tlet yMin = Number.MAX_SAFE_INTEGER\n\n\tconst nodeBoxes: NodeBoundingBox[] = nodes.map((node) => {\n\t\tconst width = Math.max(node.width || 0, 1)\n\t\tconst height = Math.max(node.height || 0, 1)\n\n\t\tconst position: XYPosition = {\n\t\t\tx: node.positionAbsolute?.x || 0,\n\t\t\ty: node.positionAbsolute?.y || 0\n\t\t}\n\n\t\tconst topLeft: XYPosition = {\n\t\t\tx: position.x - nodePadding,\n\t\t\ty: position.y - nodePadding\n\t\t}\n\t\tconst bottomLeft: XYPosition = {\n\t\t\tx: position.x - nodePadding,\n\t\t\ty: position.y + height + nodePadding\n\t\t}\n\t\tconst topRight: XYPosition = {\n\t\t\tx: position.x + width + nodePadding,\n\t\t\ty: position.y - nodePadding\n\t\t}\n\t\tconst bottomRight: XYPosition = {\n\t\t\tx: position.x + width + nodePadding,\n\t\t\ty: position.y + height + nodePadding\n\t\t}\n\n\t\tif (roundTo > 0) {\n\t\t\ttopLeft.x = roundDown(topLeft.x, roundTo)\n\t\t\ttopLeft.y = roundDown(topLeft.y, roundTo)\n\t\t\tbottomLeft.x = roundDown(bottomLeft.x, roundTo)\n\t\t\tbottomLeft.y = roundUp(bottomLeft.y, roundTo)\n\t\t\ttopRight.x = roundUp(topRight.x, roundTo)\n\t\t\ttopRight.y = roundDown(topRight.y, roundTo)\n\t\t\tbottomRight.x = roundUp(bottomRight.x, roundTo)\n\t\t\tbottomRight.y = roundUp(bottomRight.y, roundTo)\n\t\t}\n\n\t\tif (topLeft.y < yMin) yMin = topLeft.y\n\t\tif (topLeft.x < xMin) xMin = topLeft.x\n\t\tif (bottomRight.y > yMax) yMax = bottomRight.y\n\t\tif (bottomRight.x > xMax) xMax = bottomRight.x\n\n\t\treturn {\n\t\t\tid: node.id,\n\t\t\twidth,\n\t\t\theight,\n\t\t\ttopLeft,\n\t\t\tbottomLeft,\n\t\t\ttopRight,\n\t\t\tbottomRight\n\t\t}\n\t})\n\n\tconst graphPadding = nodePadding * 2\n\n\txMax = roundUp(xMax + graphPadding, roundTo)\n\tyMax = roundUp(yMax + graphPadding, roundTo)\n\txMin = roundDown(xMin - graphPadding, roundTo)\n\tyMin = roundDown(yMin - graphPadding, roundTo)\n\n\tconst topLeft: XYPosition = {\n\t\tx: xMin,\n\t\ty: yMin\n\t}\n\n\tconst bottomLeft: XYPosition = {\n\t\tx: xMin,\n\t\ty: yMax\n\t}\n\n\tconst topRight: XYPosition = {\n\t\tx: xMax,\n\t\ty: yMin\n\t}\n\n\tconst bottomRight: XYPosition = {\n\t\tx: xMax,\n\t\ty: yMax\n\t}\n\n\tconst width = Math.abs(topLeft.x - topRight.x)\n\tconst height = Math.abs(topLeft.y - bottomLeft.y)\n\n\tconst graphBox: GraphBoundingBox = {\n\t\ttopLeft,\n\t\tbottomLeft,\n\t\ttopRight,\n\t\tbottomRight,\n\t\twidth,\n\t\theight,\n\t\txMax,\n\t\tyMax,\n\t\txMin,\n\t\tyMin\n\t}\n\n\treturn { nodeBoxes, graphBox }\n}\n", "import {\n\tcreateGrid,\n\tgetBoundingBoxes,\n\tgridToGraphPoint,\n\tpathfindingAStarDiagonal,\n\tsvgDrawSmoothLinePath,\n\ttoInteger\n} from '../functions'\nimport type {\n\tPointInfo,\n\tPathFindingFunction,\n\tSVGDrawFunction\n} from '../functions'\nimport type { Node, EdgeProps } from 'react-flow-renderer'\n\nexport type EdgeParams = Pick<\n\tEdgeProps,\n\t| 'sourceX'\n\t| 'sourceY'\n\t| 'targetX'\n\t| 'targetY'\n\t| 'sourcePosition'\n\t| 'targetPosition'\n>\n\nexport type GetSmartEdgeOptions = {\n\tgridRatio?: number\n\tnodePadding?: number\n\tdrawEdge?: SVGDrawFunction\n\tgeneratePath?: PathFindingFunction\n}\n\nexport type GetSmartEdgeParams<NodeDataType = unknown> = EdgeParams & {\n\toptions?: GetSmartEdgeOptions\n\tnodes: Node<NodeDataType>[]\n}\n\nexport type GetSmartEdgeReturn = {\n\tsvgPathString: string\n\tedgeCenterX: number\n\tedgeCenterY: number\n}\n\nexport const getSmartEdge = <NodeDataType = unknown>({\n\toptions = {},\n\tnodes = [],\n\tsourceX,\n\tsourceY,\n\ttargetX,\n\ttargetY,\n\tsourcePosition,\n\ttargetPosition\n}: GetSmartEdgeParams<NodeDataType>): GetSmartEdgeReturn | null => {\n\ttry {\n\t\tconst {\n\t\t\tdrawEdge = svgDrawSmoothLinePath,\n\t\t\tgeneratePath = pathfindingAStarDiagonal\n\t\t} = options\n\n\t\tlet { gridRatio = 10, nodePadding = 10 } = options\n\t\tgridRatio = toInteger(gridRatio)\n\t\tnodePadding = toInteger(nodePadding)\n\n\t\t// We use the node's information to generate bounding boxes for them\n\t\t// and the graph\n\t\tconst { graphBox, nodeBoxes } = getBoundingBoxes<NodeDataType>(\n\t\t\tnodes,\n\t\t\tnodePadding,\n\t\t\tgridRatio\n\t\t)\n\n\t\tconst source: PointInfo = {\n\t\t\tx: sourceX,\n\t\t\ty: sourceY,\n\t\t\tposition: sourcePosition\n\t\t}\n\n\t\tconst target: PointInfo = {\n\t\t\tx: targetX,\n\t\t\ty: targetY,\n\t\t\tposition: targetPosition\n\t\t}\n\n\t\t// With this information, we can create a 2D grid representation of\n\t\t// our graph, that tells us where in the graph there is a \"free\" space or not\n\t\tconst { grid, start, end } = createGrid(\n\t\t\tgraphBox,\n\t\t\tnodeBoxes,\n\t\t\tsource,\n\t\t\ttarget,\n\t\t\tgridRatio\n\t\t)\n\n\t\t// We then can use the grid representation to do pathfinding\n\t\tconst generatePathResult = generatePath(grid, start, end)\n\n\t\tif (generatePathResult === null) {\n\t\t\treturn null\n\t\t}\n\n\t\tconst { fullPath, smoothedPath } = generatePathResult\n\n\t\t// Here we convert the grid path to a sequence of graph coordinates.\n\t\tconst graphPath = smoothedPath.map((gridPoint) => {\n\t\t\tconst [x, y] = gridPoint\n\t\t\tconst graphPoint = gridToGraphPoint(\n\t\t\t\t{ x, y },\n\t\t\t\tgraphBox.xMin,\n\t\t\t\tgraphBox.yMin,\n\t\t\t\tgridRatio\n\t\t\t)\n\t\t\treturn [graphPoint.x, graphPoint.y]\n\t\t})\n\n\t\t// Finally, we can use the graph path to draw the edge\n\t\tconst svgPathString = drawEdge(source, target, graphPath)\n\n\t\t// Compute the edge's middle point using the full path, so users can use\n\t\t// it to position their custom labels\n\t\tconst index = Math.floor(fullPath.length / 2)\n\t\tconst middlePoint = fullPath[index]\n\t\tconst [middleX, middleY] = middlePoint\n\t\tconst { x: edgeCenterX, y: edgeCenterY } = gridToGraphPoint(\n\t\t\t{ x: middleX, y: middleY },\n\t\t\tgraphBox.xMin,\n\t\t\tgraphBox.yMin,\n\t\t\tgridRatio\n\t\t)\n\n\t\treturn { svgPathString, edgeCenterX, edgeCenterY }\n\t} catch {\n\t\treturn null\n\t}\n}\n\nexport type GetSmartEdgeFunction = typeof getSmartEdge\n", "import React from 'react'\nimport { EdgeText, BezierEdge } from 'react-flow-renderer'\nimport { getSmartEdge } from '../getSmartEdge'\nimport type { GetSmartEdgeOptions } from '../getSmartEdge'\nimport type { EdgeProps, Node } from 'react-flow-renderer'\n\nexport type EdgeElement = typeof BezierEdge\n\nexport type SmartEdgeOptions = GetSmartEdgeOptions & {\n\tfallback?: EdgeElement\n}\n\nexport interface SmartEdgeProps<EdgeDataType = unknown, NodeDataType = unknown>\n\textends EdgeProps<EdgeDataType> {\n\tnodes: Node<NodeDataType>[]\n\toptions: SmartEdgeOptions\n}\n\nexport function SmartEdge<EdgeDataType = unknown, NodeDataType = unknown>({\n\tnodes,\n\toptions,\n\t...edgeProps\n}: SmartEdgeProps<EdgeDataType, NodeDataType>) {\n\tconst {\n\t\tsourceX,\n\t\tsourceY,\n\t\tsourcePosition,\n\t\ttargetX,\n\t\ttargetY,\n\t\ttargetPosition,\n\t\tstyle,\n\t\tlabel,\n\t\tlabelStyle,\n\t\tlabelShowBg,\n\t\tlabelBgStyle,\n\t\tlabelBgPadding,\n\t\tlabelBgBorderRadius,\n\t\tmarkerEnd,\n\t\tmarkerStart\n\t} = edgeProps\n\n\tconst smartResponse = getSmartEdge({\n\t\tsourcePosition,\n\t\ttargetPosition,\n\t\tsourceX,\n\t\tsourceY,\n\t\ttargetX,\n\t\ttargetY,\n\t\toptions,\n\t\tnodes\n\t})\n\n\tconst FallbackEdge = options.fallback || BezierEdge\n\n\tif (smartResponse === null) {\n\t\treturn <FallbackEdge {...edgeProps} />\n\t}\n\n\tconst { edgeCenterX, edgeCenterY, svgPathString } = smartResponse\n\n\tlet edgeLabel: JSX.Element | null = null\n\tconst hasStringLabel = !!label && typeof label === 'string'\n\n\tif (hasStringLabel) {\n\t\tedgeLabel = (\n\t\t\t<EdgeText\n\t\t\t\tx={edgeCenterX}\n\t\t\t\ty={edgeCenterY}\n\t\t\t\tlabel={label}\n\t\t\t\tlabelStyle={labelStyle}\n\t\t\t\tlabelShowBg={labelShowBg}\n\t\t\t\tlabelBgStyle={labelBgStyle}\n\t\t\t\tlabelBgPadding={labelBgPadding}\n\t\t\t\tlabelBgBorderRadius={labelBgBorderRadius}\n\t\t\t/>\n\t\t)\n\t}\n\n\treturn (\n\t\t<>\n\t\t\t<path\n\t\t\t\tstyle={style}\n\t\t\t\tclassName='react-flow__edge-path'\n\t\t\t\td={svgPathString}\n\t\t\t\tmarkerEnd={markerEnd}\n\t\t\t\tmarkerStart={markerStart}\n\t\t\t/>\n\t\t\t{edgeLabel}\n\t\t</>\n\t)\n}\n\nexport type SmartEdgeFunction = typeof SmartEdge\n", "import React from 'react'\nimport { useNodes, BezierEdge } from 'react-flow-renderer'\nimport { SmartEdge } from '../SmartEdge'\nimport { svgDrawSmoothLinePath, pathfindingAStarDiagonal } from '../functions'\nimport type { SmartEdgeOptions } from '../SmartEdge'\nimport type { EdgeProps } from 'react-flow-renderer'\n\nconst BezierConfiguration: SmartEdgeOptions = {\n\tdrawEdge: svgDrawSmoothLinePath,\n\tgeneratePath: pathfindingAStarDiagonal,\n\tfallback: BezierEdge\n}\n\nexport function SmartBezierEdge<EdgeDataType = unknown, NodeDataType = unknown>(\n\tprops: EdgeProps<EdgeDataType>\n) {\n\tconst nodes = useNodes<NodeDataType>()\n\n\treturn (\n\t\t<SmartEdge<EdgeDataType, NodeDataType>\n\t\t\t{...props}\n\t\t\toptions={BezierConfiguration}\n\t\t\tnodes={nodes}\n\t\t/>\n\t)\n}\n", "import React from 'react'\nimport { useNodes, StepEdge } from 'react-flow-renderer'\nimport { SmartEdge } from '../SmartEdge'\nimport {\n\tsvgDrawStraightLinePath,\n\tpathfindingJumpPointNoDiagonal\n} from '../functions'\nimport type { SmartEdgeOptions } from '../SmartEdge'\nimport type { EdgeProps } from 'react-flow-renderer'\n\nconst StepConfiguration: SmartEdgeOptions = {\n\tdrawEdge: svgDrawStraightLinePath,\n\tgeneratePath: pathfindingJumpPointNoDiagonal,\n\tfallback: StepEdge\n}\n\nexport function SmartStepEdge<EdgeDataType = unknown, NodeDataType = unknown>(\n\tprops: EdgeProps<EdgeDataType>\n) {\n\tconst nodes = useNodes<NodeDataType>()\n\n\treturn (\n\t\t<SmartEdge<EdgeDataType, NodeDataType>\n\t\t\t{...props}\n\t\t\toptions={StepConfiguration}\n\t\t\tnodes={nodes}\n\t\t/>\n\t)\n}\n", "import React from 'react'\nimport { useNodes, StraightEdge } from 'react-flow-renderer'\nimport { SmartEdge } from '../SmartEdge'\nimport {\n\tsvgDrawStraightLinePath,\n\tpathfindingAStarNoDiagonal\n} from '../functions'\nimport type { SmartEdgeOptions } from '../SmartEdge'\nimport type { EdgeProps } from 'react-flow-renderer'\n\nconst StraightConfiguration: SmartEdgeOptions = {\n\tdrawEdge: svgDrawStraightLinePath,\n\tgeneratePath: pathfindingAStarNoDiagonal,\n\tfallback: StraightEdge\n}\n\nexport function SmartStraightEdge<\n\tEdgeDataType = unknown,\n\tNodeDataType = unknown\n>(props: EdgeProps<EdgeDataType>) {\n\tconst nodes = useNodes<NodeDataType>()\n\n\treturn (\n\t\t<SmartEdge<EdgeDataType, NodeDataType>\n\t\t\t{...props}\n\t\t\toptions={StraightConfiguration}\n\t\t\tnodes={nodes}\n\t\t/>\n\t)\n}\n"],
  "mappings": "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;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;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",
  "names": ["_j", "_ref", "Heap", "require_heap", "DiagonalMovement", "DiagonalMovement", "Grid", "Util", "DiagonalMovement", "AStarFinder", "AStarFinder", "Util", "DiagonalMovement", "AStarFinder", "Util", "DiagonalMovement", "Util", "DiagonalMovement", "Util", "DiagonalMovement", "route", "t", "Util", "DiagonalMovement", "DiagonalMovement", "DiagonalMovement", "DiagonalMovement", "DiagonalMovement", "DiagonalMovement", "JumpPointFinder", "selector", "useStore", "import_react", "createContext$1", "Provider", "createStore", "useStore", "selector", "useStoreApi", "arrayLikeToArray", "arrayWithHoles", "iterableToArrayLimit", "unsupportedIterableToArray", "nonIterableRest", "arrayLikeToArray", "arrayWithoutHoles", "iterableToArray", "unsupportedIterableToArray", "nonIterableSpread", "objectWithoutPropertiesLoose", "import_react", "MiniMapNode", "React", "selector", "getAttrFunction", "MiniMap", "index", "import_react", "createGridLinesPath", "React", "createGridDotsPath", "ownKeys", "_objectSpread", "transformSelector", "Background", "index", "import_react", "nodesSelector", "obj", "getNextPointFromPosition", "point", "position", "x", "y", "guaranteeWalkablePath", "grid", "node", "getNodeAt", "walkable", "setWalkableAt", "next", "graphToGridPoint", "graphPoint", "smallestX", "smallestY", "gridRatio", "referenceX", "referenceY", "gridToGraphPoint", "gridPoint", "round", "multiple", "Math", "roundDown", "floor", "roundUp", "ceil", "toInteger", "value", "min", "result", "max", "Number", "isInteger", "createGrid", "graph", "nodes", "source", "target", "xMin", "yMin", "width", "height", "mapColumns", "mapRows", "Grid", "forEach", "nodeStart", "topLeft", "nodeEnd", "bottomRight", "startGrid", "endGrid", "startingNode", "endingNode", "start", "end", "svgDrawStraightLinePath", "path", "svgPathString", "svgDrawSmoothLinePath", "points", "quadraticBezierCurve", "X", "Y", "first", "svgPath", "i", "length", "midPoint", "getMidPoint", "last", "Ax", "Ay", "Bx", "By", "Zx", "Zy", "pathfindingAStarDiagonal", "finder", "AStarFinder", "diagonalMovement", "DiagonalMovement", "Always", "fullPath", "findPath", "smoothedPath", "Util", "smoothenPath", "pathfindingAStarNoDiagonal", "Never", "pathfindingJumpPointNoDiagonal", "JumpPointFinder", "getBoundingBoxes", "nodePadding", "roundTo", "xMax", "MIN_SAFE_INTEGER", "yMax", "MAX_SAFE_INTEGER", "nodeBoxes", "map", "positionAbsolute", "bottomLeft", "topRight", "id", "graphPadding", "abs", "graphBox", "getSmartEdge", "options", "sourceX", "sourceY", "targetX", "targetY", "sourcePosition", "targetPosition", "drawEdge", "generatePath", "generatePathResult", "graphPath", "index", "middlePoint", "middleX", "middleY", "edgeCenterX", "edgeCenterY", "SmartEdge", "edgeProps", "_objectWithoutPropertiesLoose", "_excluded", "style", "label", "labelStyle", "labelShowBg", "labelBgStyle", "labelBgPadding", "labelBgBorderRadius", "markerEnd", "markerStart", "smartResponse", "FallbackEdge", "fallback", "BezierEdge", "React", "createElement", "edgeLabel", "hasStringLabel", "EdgeText", "Fragment", "className", "d", "BezierConfiguration", "SmartBezierEdge", "props", "useNodes", "StepConfiguration", "StepEdge", "SmartStepEdge", "StraightConfiguration", "StraightEdge", "SmartStraightEdge"]
}
