import React from 'react';
import { EdgeText, BezierEdge, useNodes, StepEdge, StraightEdge } from 'react-flow-renderer';
import { Grid, AStarFinder, DiagonalMovement, Util, JumpPointFinder } from 'pathfinding';

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;

  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }

  return target;
}

var getNextPointFromPosition = function getNextPointFromPosition(point, position) {
  switch (position) {
    case 'top':
      return {
        x: point.x,
        y: point.y - 1
      };

    case 'bottom':
      return {
        x: point.x,
        y: point.y + 1
      };

    case 'left':
      return {
        x: point.x - 1,
        y: point.y
      };

    case 'right':
      return {
        x: point.x + 1,
        y: point.y
      };
  }
};
/**
 * Guarantee that the path is walkable, even if the point is inside a non
 * walkable area, by adding a walkable path in the direction of the point's
 * Position.
 */

var guaranteeWalkablePath = function guaranteeWalkablePath(grid, point, position) {
  var node = grid.getNodeAt(point.x, point.y);

  while (!node.walkable) {
    grid.setWalkableAt(node.x, node.y, true);
    var next = getNextPointFromPosition(node, position);
    node = grid.getNodeAt(next.x, next.y);
  }
};

/**
 * Each bounding box is a collection of X/Y points in a graph, and we
 * need to convert them to "occupied" cells in a 2D grid representation.
 *
 * The top most position of the grid (grid[0][0]) needs to be equivalent
 * to the top most point in the graph (the graph.topLeft point).
 *
 * Since the top most point can have X/Y values different than zero,
 * and each cell in a grid represents a 10x10 pixel area in the grid (or a
 * gridRatio area), there's need to be a conversion between a point in a graph
 * to a point in the grid.
 *
 * We do this conversion by dividing a graph point X/Y values by the grid ratio,
 * and "shifting" their values up or down, depending on the values of the top
 * most point in the graph. The top most point in the graph will have the
 * smallest values for X and Y.
 *
 * We avoid setting nodes in the border of the grid (x=0 or y=0), so there's
 * always a "walkable" area around the grid.
 */
var graphToGridPoint = function graphToGridPoint(graphPoint, smallestX, smallestY, gridRatio) {
  var x = graphPoint.x / gridRatio;
  var y = graphPoint.y / gridRatio;
  var referenceX = smallestX / gridRatio;
  var referenceY = smallestY / gridRatio;

  if (referenceX < 1) {
    while (referenceX !== 1) {
      referenceX++;
      x++;
    }
  } else if (referenceX > 1) {
    while (referenceX !== 1) {
      referenceX--;
      x--;
    }
  } else ;

  if (referenceY < 1) {
    while (referenceY !== 1) {
      referenceY++;
      y++;
    }
  } else if (referenceY > 1) {
    while (referenceY !== 1) {
      referenceY--;
      y--;
    }
  } else ;

  return {
    x: x,
    y: y
  };
};
/**
 * Converts a grid point back to a graph point, using the reverse logic of
 * graphToGridPoint.
 */

var gridToGraphPoint = function gridToGraphPoint(gridPoint, smallestX, smallestY, gridRatio) {
  var x = gridPoint.x * gridRatio;
  var y = gridPoint.y * gridRatio;
  var referenceX = smallestX;
  var referenceY = smallestY;

  if (referenceX < gridRatio) {
    while (referenceX !== gridRatio) {
      referenceX = referenceX + gridRatio;
      x = x - gridRatio;
    }
  } else if (referenceX > gridRatio) {
    while (referenceX !== gridRatio) {
      referenceX = referenceX - gridRatio;
      x = x + gridRatio;
    }
  } else ;

  if (referenceY < gridRatio) {
    while (referenceY !== gridRatio) {
      referenceY = referenceY + gridRatio;
      y = y - gridRatio;
    }
  } else if (referenceY > gridRatio) {
    while (referenceY !== gridRatio) {
      referenceY = referenceY - gridRatio;
      y = y + gridRatio;
    }
  } else ;

  return {
    x: x,
    y: y
  };
};

var round = function round(x, multiple) {
  if (multiple === void 0) {
    multiple = 10;
  }

  return Math.round(x / multiple) * multiple;
};
var roundDown = function roundDown(x, multiple) {
  if (multiple === void 0) {
    multiple = 10;
  }

  return Math.floor(x / multiple) * multiple;
};
var roundUp = function roundUp(x, multiple) {
  if (multiple === void 0) {
    multiple = 10;
  }

  return Math.ceil(x / multiple) * multiple;
};
var toInteger = function toInteger(value, min) {
  if (min === void 0) {
    min = 0;
  }

  var result = Math.max(Math.round(value), min);
  result = Number.isInteger(result) ? result : min;
  result = result >= min ? result : min;
  return result;
};

var createGrid = function createGrid(graph, nodes, source, target, gridRatio) {
  if (gridRatio === void 0) {
    gridRatio = 2;
  }

  var xMin = graph.xMin,
      yMin = graph.yMin,
      width = graph.width,
      height = graph.height; // Create a grid representation of the graph box, where each cell is
  // equivalent to 10x10 pixels (or the grid ratio) on the graph. We'll use
  // this simplified grid to do pathfinding.

  var mapColumns = roundUp(width, gridRatio) / gridRatio + 1;
  var mapRows = roundUp(height, gridRatio) / gridRatio + 1;
  var grid = new Grid(mapColumns, mapRows); // Update the grid representation with the space the nodes take up

  nodes.forEach(function (node) {
    var nodeStart = graphToGridPoint(node.topLeft, xMin, yMin, gridRatio);
    var nodeEnd = graphToGridPoint(node.bottomRight, xMin, yMin, gridRatio);

    for (var x = nodeStart.x; x < nodeEnd.x; x++) {
      for (var y = nodeStart.y; y < nodeEnd.y; y++) {
        grid.setWalkableAt(x, y, false);
      }
    }
  }); // Convert the starting and ending graph points to grid points

  var startGrid = graphToGridPoint({
    x: round(source.x, gridRatio),
    y: round(source.y, gridRatio)
  }, xMin, yMin, gridRatio);
  var endGrid = graphToGridPoint({
    x: round(target.x, gridRatio),
    y: round(target.y, gridRatio)
  }, xMin, yMin, gridRatio); // Guarantee a walkable path between the start and end points, even if the
  // source or target where covered by another node or by padding

  var startingNode = grid.getNodeAt(startGrid.x, startGrid.y);
  guaranteeWalkablePath(grid, startingNode, source.position);
  var endingNode = grid.getNodeAt(endGrid.x, endGrid.y);
  guaranteeWalkablePath(grid, endingNode, target.position); // Use the next closest points as the start and end points, so
  // pathfinding does not start too close to the nodes

  var start = getNextPointFromPosition(startingNode, source.position);
  var end = getNextPointFromPosition(endingNode, target.position);
  return {
    grid: grid,
    start: start,
    end: end
  };
};

/**
 * Draws a SVG path from a list of points, using straight lines.
 */
var svgDrawStraightLinePath = function svgDrawStraightLinePath(source, target, path) {
  var svgPathString = "M " + source.x + ", " + source.y + " ";
  path.forEach(function (point) {
    var x = point[0],
        y = point[1];
    svgPathString += "L " + x + ", " + y + " ";
  });
  svgPathString += "L " + target.x + ", " + target.y + " ";
  return svgPathString;
};
/**
 * Draws a SVG path from a list of points, using rounded lines.
 */

var svgDrawSmoothLinePath = function svgDrawSmoothLinePath(source, target, path) {
  var points = [[source.x, source.y]].concat(path, [[target.x, target.y]]);
  return quadraticBezierCurve(points);
};

var quadraticBezierCurve = function quadraticBezierCurve(points) {
  var X = 0;
  var Y = 1;
  var point = points[0];
  var first = points[0];
  var svgPath = "M" + first[X] + "," + first[Y] + "M";

  for (var i = 0; i < points.length; i++) {
    var next = points[i];
    var midPoint = getMidPoint(point[X], point[Y], next[X], next[Y]);
    svgPath += " " + midPoint[X] + "," + midPoint[Y];
    svgPath += "Q" + next[X] + "," + next[Y];
    point = next;
  }

  var last = points[points.length - 1];
  svgPath += " " + last[0] + "," + last[1];
  return svgPath;
};

var getMidPoint = function getMidPoint(Ax, Ay, Bx, By) {
  var Zx = (Ax - Bx) / 2 + Bx;
  var Zy = (Ay - By) / 2 + By;
  return [Zx, Zy];
};

// FIXME: The "pathfinding" module doe not have proper typings.
var pathfindingAStarDiagonal = function pathfindingAStarDiagonal(grid, start, end) {
  try {
    var finder = new AStarFinder({
      diagonalMovement: DiagonalMovement.Always
    });
    var fullPath = finder.findPath(start.x, start.y, end.x, end.y, grid);
    var smoothedPath = Util.smoothenPath(grid, fullPath);
    if (fullPath.length === 0 || smoothedPath.length === 0) return null;
    return {
      fullPath: fullPath,
      smoothedPath: smoothedPath
    };
  } catch (_unused) {
    return null;
  }
};
var pathfindingAStarNoDiagonal = function pathfindingAStarNoDiagonal(grid, start, end) {
  try {
    var finder = new AStarFinder({
      diagonalMovement: DiagonalMovement.Never
    });
    var fullPath = finder.findPath(start.x, start.y, end.x, end.y, grid);
    var smoothedPath = Util.smoothenPath(grid, fullPath);
    if (fullPath.length === 0 || smoothedPath.length === 0) return null;
    return {
      fullPath: fullPath,
      smoothedPath: smoothedPath
    };
  } catch (_unused2) {
    return null;
  }
};
var pathfindingJumpPointNoDiagonal = function pathfindingJumpPointNoDiagonal(grid, start, end) {
  try {
    // FIXME: The "pathfinding" module doe not have proper typings.
    // @ts-ignore
    var finder = new JumpPointFinder({
      diagonalMovement: DiagonalMovement.Never
    });
    var fullPath = finder.findPath(start.x, start.y, end.x, end.y, grid);
    var smoothedPath = fullPath;
    if (fullPath.length === 0 || smoothedPath.length === 0) return null;
    return {
      fullPath: fullPath,
      smoothedPath: smoothedPath
    };
  } catch (_unused3) {
    return null;
  }
};

/**
 * Get the bounding box of all nodes and the graph itself, as X/Y coordinates
 * of all corner points.
 *
 * @param nodes The node list
 * @param nodePadding Optional padding to add to the node's and graph bounding boxes
 * @param roundTo Everything will be rounded to this nearest integer
 * @returns Graph and nodes bounding boxes.
 */

var getBoundingBoxes = function getBoundingBoxes(nodes, nodePadding, roundTo) {
  if (nodePadding === void 0) {
    nodePadding = 2;
  }

  if (roundTo === void 0) {
    roundTo = 2;
  }

  var xMax = Number.MIN_SAFE_INTEGER;
  var yMax = Number.MIN_SAFE_INTEGER;
  var xMin = Number.MAX_SAFE_INTEGER;
  var yMin = Number.MAX_SAFE_INTEGER;
  var nodeBoxes = nodes.map(function (node) {
    var _node$positionAbsolut, _node$positionAbsolut2;

    var width = Math.max(node.width || 0, 1);
    var height = Math.max(node.height || 0, 1);
    var position = {
      x: ((_node$positionAbsolut = node.positionAbsolute) == null ? void 0 : _node$positionAbsolut.x) || 0,
      y: ((_node$positionAbsolut2 = node.positionAbsolute) == null ? void 0 : _node$positionAbsolut2.y) || 0
    };
    var topLeft = {
      x: position.x - nodePadding,
      y: position.y - nodePadding
    };
    var bottomLeft = {
      x: position.x - nodePadding,
      y: position.y + height + nodePadding
    };
    var topRight = {
      x: position.x + width + nodePadding,
      y: position.y - nodePadding
    };
    var bottomRight = {
      x: position.x + width + nodePadding,
      y: position.y + height + nodePadding
    };

    if (roundTo > 0) {
      topLeft.x = roundDown(topLeft.x, roundTo);
      topLeft.y = roundDown(topLeft.y, roundTo);
      bottomLeft.x = roundDown(bottomLeft.x, roundTo);
      bottomLeft.y = roundUp(bottomLeft.y, roundTo);
      topRight.x = roundUp(topRight.x, roundTo);
      topRight.y = roundDown(topRight.y, roundTo);
      bottomRight.x = roundUp(bottomRight.x, roundTo);
      bottomRight.y = roundUp(bottomRight.y, roundTo);
    }

    if (topLeft.y < yMin) yMin = topLeft.y;
    if (topLeft.x < xMin) xMin = topLeft.x;
    if (bottomRight.y > yMax) yMax = bottomRight.y;
    if (bottomRight.x > xMax) xMax = bottomRight.x;
    return {
      id: node.id,
      width: width,
      height: height,
      topLeft: topLeft,
      bottomLeft: bottomLeft,
      topRight: topRight,
      bottomRight: bottomRight
    };
  });
  var graphPadding = nodePadding * 2;
  xMax = roundUp(xMax + graphPadding, roundTo);
  yMax = roundUp(yMax + graphPadding, roundTo);
  xMin = roundDown(xMin - graphPadding, roundTo);
  yMin = roundDown(yMin - graphPadding, roundTo);
  var topLeft = {
    x: xMin,
    y: yMin
  };
  var bottomLeft = {
    x: xMin,
    y: yMax
  };
  var topRight = {
    x: xMax,
    y: yMin
  };
  var bottomRight = {
    x: xMax,
    y: yMax
  };
  var width = Math.abs(topLeft.x - topRight.x);
  var height = Math.abs(topLeft.y - bottomLeft.y);
  var graphBox = {
    topLeft: topLeft,
    bottomLeft: bottomLeft,
    topRight: topRight,
    bottomRight: bottomRight,
    width: width,
    height: height,
    xMax: xMax,
    yMax: yMax,
    xMin: xMin,
    yMin: yMin
  };
  return {
    nodeBoxes: nodeBoxes,
    graphBox: graphBox
  };
};

var getSmartEdge = function getSmartEdge(_ref) {
  var _ref$options = _ref.options,
      options = _ref$options === void 0 ? {} : _ref$options,
      _ref$nodes = _ref.nodes,
      nodes = _ref$nodes === void 0 ? [] : _ref$nodes,
      sourceX = _ref.sourceX,
      sourceY = _ref.sourceY,
      targetX = _ref.targetX,
      targetY = _ref.targetY,
      sourcePosition = _ref.sourcePosition,
      targetPosition = _ref.targetPosition;

  try {
    var _options$drawEdge = options.drawEdge,
        drawEdge = _options$drawEdge === void 0 ? svgDrawSmoothLinePath : _options$drawEdge,
        _options$generatePath = options.generatePath,
        generatePath = _options$generatePath === void 0 ? pathfindingAStarDiagonal : _options$generatePath;
    var _options$gridRatio = options.gridRatio,
        gridRatio = _options$gridRatio === void 0 ? 10 : _options$gridRatio,
        _options$nodePadding = options.nodePadding,
        nodePadding = _options$nodePadding === void 0 ? 10 : _options$nodePadding;
    gridRatio = toInteger(gridRatio);
    nodePadding = toInteger(nodePadding); // We use the node's information to generate bounding boxes for them
    // and the graph

    var _getBoundingBoxes = getBoundingBoxes(nodes, nodePadding, gridRatio),
        graphBox = _getBoundingBoxes.graphBox,
        nodeBoxes = _getBoundingBoxes.nodeBoxes;

    var source = {
      x: sourceX,
      y: sourceY,
      position: sourcePosition
    };
    var target = {
      x: targetX,
      y: targetY,
      position: targetPosition
    }; // With this information, we can create a 2D grid representation of
    // our graph, that tells us where in the graph there is a "free" space or not

    var _createGrid = createGrid(graphBox, nodeBoxes, source, target, gridRatio),
        grid = _createGrid.grid,
        start = _createGrid.start,
        end = _createGrid.end; // We then can use the grid representation to do pathfinding


    var generatePathResult = generatePath(grid, start, end);

    if (generatePathResult === null) {
      return null;
    }

    var fullPath = generatePathResult.fullPath,
        smoothedPath = generatePathResult.smoothedPath; // Here we convert the grid path to a sequence of graph coordinates.

    var graphPath = smoothedPath.map(function (gridPoint) {
      var x = gridPoint[0],
          y = gridPoint[1];
      var graphPoint = gridToGraphPoint({
        x: x,
        y: y
      }, graphBox.xMin, graphBox.yMin, gridRatio);
      return [graphPoint.x, graphPoint.y];
    }); // Finally, we can use the graph path to draw the edge

    var svgPathString = drawEdge(source, target, graphPath); // Compute the edge's middle point using the full path, so users can use
    // it to position their custom labels

    var index = Math.floor(fullPath.length / 2);
    var middlePoint = fullPath[index];
    var middleX = middlePoint[0],
        middleY = middlePoint[1];

    var _gridToGraphPoint = gridToGraphPoint({
      x: middleX,
      y: middleY
    }, graphBox.xMin, graphBox.yMin, gridRatio),
        edgeCenterX = _gridToGraphPoint.x,
        edgeCenterY = _gridToGraphPoint.y;

    return {
      svgPathString: svgPathString,
      edgeCenterX: edgeCenterX,
      edgeCenterY: edgeCenterY
    };
  } catch (_unused) {
    return null;
  }
};

var _excluded = ["nodes", "options"];
function SmartEdge(_ref) {
  var nodes = _ref.nodes,
      options = _ref.options,
      edgeProps = _objectWithoutPropertiesLoose(_ref, _excluded);

  var sourceX = edgeProps.sourceX,
      sourceY = edgeProps.sourceY,
      sourcePosition = edgeProps.sourcePosition,
      targetX = edgeProps.targetX,
      targetY = edgeProps.targetY,
      targetPosition = edgeProps.targetPosition,
      style = edgeProps.style,
      label = edgeProps.label,
      labelStyle = edgeProps.labelStyle,
      labelShowBg = edgeProps.labelShowBg,
      labelBgStyle = edgeProps.labelBgStyle,
      labelBgPadding = edgeProps.labelBgPadding,
      labelBgBorderRadius = edgeProps.labelBgBorderRadius,
      markerEnd = edgeProps.markerEnd,
      markerStart = edgeProps.markerStart;
  var smartResponse = getSmartEdge({
    sourcePosition: sourcePosition,
    targetPosition: targetPosition,
    sourceX: sourceX,
    sourceY: sourceY,
    targetX: targetX,
    targetY: targetY,
    options: options,
    nodes: nodes
  });
  var FallbackEdge = options.fallback || BezierEdge;

  if (smartResponse === null) {
    return React.createElement(FallbackEdge, _extends({}, edgeProps));
  }

  var edgeCenterX = smartResponse.edgeCenterX,
      edgeCenterY = smartResponse.edgeCenterY,
      svgPathString = smartResponse.svgPathString;
  var edgeLabel = null;
  var hasStringLabel = !!label && typeof label === 'string';

  if (hasStringLabel) {
    edgeLabel = React.createElement(EdgeText, {
      x: edgeCenterX,
      y: edgeCenterY,
      label: label,
      labelStyle: labelStyle,
      labelShowBg: labelShowBg,
      labelBgStyle: labelBgStyle,
      labelBgPadding: labelBgPadding,
      labelBgBorderRadius: labelBgBorderRadius
    });
  }

  return React.createElement(React.Fragment, null, React.createElement("path", {
    style: style,
    className: 'react-flow__edge-path',
    d: svgPathString,
    markerEnd: markerEnd,
    markerStart: markerStart
  }), edgeLabel);
}

var BezierConfiguration = {
  drawEdge: svgDrawSmoothLinePath,
  generatePath: pathfindingAStarDiagonal,
  fallback: BezierEdge
};
function SmartBezierEdge(props) {
  var nodes = useNodes();
  return React.createElement(SmartEdge, _extends({}, props, {
    options: BezierConfiguration,
    nodes: nodes
  }));
}

var StepConfiguration = {
  drawEdge: svgDrawStraightLinePath,
  generatePath: pathfindingJumpPointNoDiagonal,
  fallback: StepEdge
};
function SmartStepEdge(props) {
  var nodes = useNodes();
  return React.createElement(SmartEdge, _extends({}, props, {
    options: StepConfiguration,
    nodes: nodes
  }));
}

var StraightConfiguration = {
  drawEdge: svgDrawStraightLinePath,
  generatePath: pathfindingAStarNoDiagonal,
  fallback: StraightEdge
};
function SmartStraightEdge(props) {
  var nodes = useNodes();
  return React.createElement(SmartEdge, _extends({}, props, {
    options: StraightConfiguration,
    nodes: nodes
  }));
}

export { SmartBezierEdge, SmartEdge, SmartStepEdge, SmartStraightEdge, SmartBezierEdge as default, getSmartEdge, pathfindingAStarDiagonal, pathfindingAStarNoDiagonal, pathfindingJumpPointNoDiagonal, svgDrawSmoothLinePath, svgDrawStraightLinePath };
//# sourceMappingURL=react-flow-smart-edge.esm.js.map
